
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model account
 * 
 */
export type account = $Result.DefaultSelection<Prisma.$accountPayload>
/**
 * Model company
 * 
 */
export type company = $Result.DefaultSelection<Prisma.$companyPayload>
/**
 * Model company_known_companies
 * 
 */
export type company_known_companies = $Result.DefaultSelection<Prisma.$company_known_companiesPayload>
/**
 * Model company_paymentoptions
 * The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
 */
export type company_paymentoptions = $Result.DefaultSelection<Prisma.$company_paymentoptionsPayload>
/**
 * Model company_update_requests
 * 
 */
export type company_update_requests = $Result.DefaultSelection<Prisma.$company_update_requestsPayload>
/**
 * Model companyupdaterequest_newpaymentoptions
 * The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
 */
export type companyupdaterequest_newpaymentoptions = $Result.DefaultSelection<Prisma.$companyupdaterequest_newpaymentoptionsPayload>
/**
 * Model order_table
 * 
 */
export type order_table = $Result.DefaultSelection<Prisma.$order_tablePayload>
/**
 * Model orderitem
 * 
 */
export type orderitem = $Result.DefaultSelection<Prisma.$orderitemPayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.accountDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.companyDelegate<ExtArgs>;

  /**
   * `prisma.company_known_companies`: Exposes CRUD operations for the **company_known_companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_known_companies
    * const company_known_companies = await prisma.company_known_companies.findMany()
    * ```
    */
  get company_known_companies(): Prisma.company_known_companiesDelegate<ExtArgs>;

  /**
   * `prisma.company_paymentoptions`: Exposes CRUD operations for the **company_paymentoptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_paymentoptions
    * const company_paymentoptions = await prisma.company_paymentoptions.findMany()
    * ```
    */
  get company_paymentoptions(): Prisma.company_paymentoptionsDelegate<ExtArgs>;

  /**
   * `prisma.company_update_requests`: Exposes CRUD operations for the **company_update_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_update_requests
    * const company_update_requests = await prisma.company_update_requests.findMany()
    * ```
    */
  get company_update_requests(): Prisma.company_update_requestsDelegate<ExtArgs>;

  /**
   * `prisma.companyupdaterequest_newpaymentoptions`: Exposes CRUD operations for the **companyupdaterequest_newpaymentoptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companyupdaterequest_newpaymentoptions
    * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.findMany()
    * ```
    */
  get companyupdaterequest_newpaymentoptions(): Prisma.companyupdaterequest_newpaymentoptionsDelegate<ExtArgs>;

  /**
   * `prisma.order_table`: Exposes CRUD operations for the **order_table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_tables
    * const order_tables = await prisma.order_table.findMany()
    * ```
    */
  get order_table(): Prisma.order_tableDelegate<ExtArgs>;

  /**
   * `prisma.orderitem`: Exposes CRUD operations for the **orderitem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orderitems
    * const orderitems = await prisma.orderitem.findMany()
    * ```
    */
  get orderitem(): Prisma.orderitemDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    account: 'account',
    company: 'company',
    company_known_companies: 'company_known_companies',
    company_paymentoptions: 'company_paymentoptions',
    company_update_requests: 'company_update_requests',
    companyupdaterequest_newpaymentoptions: 'companyupdaterequest_newpaymentoptions',
    order_table: 'order_table',
    orderitem: 'orderitem',
    product: 'product',
    notification: 'notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'account' | 'company' | 'company_known_companies' | 'company_paymentoptions' | 'company_update_requests' | 'companyupdaterequest_newpaymentoptions' | 'order_table' | 'orderitem' | 'product' | 'notification'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      account: {
        payload: Prisma.$accountPayload<ExtArgs>
        fields: Prisma.accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findFirst: {
            args: Prisma.accountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findMany: {
            args: Prisma.accountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload>[]
          }
          create: {
            args: Prisma.accountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          createMany: {
            args: Prisma.accountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.accountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          update: {
            args: Prisma.accountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          deleteMany: {
            args: Prisma.accountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.accountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.accountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.accountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      company: {
        payload: Prisma.$companyPayload<ExtArgs>
        fields: Prisma.companyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          findFirst: {
            args: Prisma.companyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          findMany: {
            args: Prisma.companyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>[]
          }
          create: {
            args: Prisma.companyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          createMany: {
            args: Prisma.companyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.companyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          update: {
            args: Prisma.companyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          deleteMany: {
            args: Prisma.companyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.companyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.companyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.companyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      company_known_companies: {
        payload: Prisma.$company_known_companiesPayload<ExtArgs>
        fields: Prisma.company_known_companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_known_companiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_known_companiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload>
          }
          findFirst: {
            args: Prisma.company_known_companiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_known_companiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload>
          }
          findMany: {
            args: Prisma.company_known_companiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload>[]
          }
          create: {
            args: Prisma.company_known_companiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload>
          }
          createMany: {
            args: Prisma.company_known_companiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.company_known_companiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload>
          }
          update: {
            args: Prisma.company_known_companiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload>
          }
          deleteMany: {
            args: Prisma.company_known_companiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.company_known_companiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.company_known_companiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_known_companiesPayload>
          }
          aggregate: {
            args: Prisma.Company_known_companiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany_known_companies>
          }
          groupBy: {
            args: Prisma.company_known_companiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Company_known_companiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_known_companiesCountArgs<ExtArgs>,
            result: $Utils.Optional<Company_known_companiesCountAggregateOutputType> | number
          }
        }
      }
      company_paymentoptions: {
        payload: Prisma.$company_paymentoptionsPayload<ExtArgs>
        fields: Prisma.company_paymentoptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_paymentoptionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_paymentoptionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload>
          }
          findFirst: {
            args: Prisma.company_paymentoptionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_paymentoptionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload>
          }
          findMany: {
            args: Prisma.company_paymentoptionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload>[]
          }
          create: {
            args: Prisma.company_paymentoptionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload>
          }
          createMany: {
            args: Prisma.company_paymentoptionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.company_paymentoptionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload>
          }
          update: {
            args: Prisma.company_paymentoptionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload>
          }
          deleteMany: {
            args: Prisma.company_paymentoptionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.company_paymentoptionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.company_paymentoptionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_paymentoptionsPayload>
          }
          aggregate: {
            args: Prisma.Company_paymentoptionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany_paymentoptions>
          }
          groupBy: {
            args: Prisma.company_paymentoptionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Company_paymentoptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_paymentoptionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Company_paymentoptionsCountAggregateOutputType> | number
          }
        }
      }
      company_update_requests: {
        payload: Prisma.$company_update_requestsPayload<ExtArgs>
        fields: Prisma.company_update_requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_update_requestsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_update_requestsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload>
          }
          findFirst: {
            args: Prisma.company_update_requestsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_update_requestsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload>
          }
          findMany: {
            args: Prisma.company_update_requestsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload>[]
          }
          create: {
            args: Prisma.company_update_requestsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload>
          }
          createMany: {
            args: Prisma.company_update_requestsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.company_update_requestsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload>
          }
          update: {
            args: Prisma.company_update_requestsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload>
          }
          deleteMany: {
            args: Prisma.company_update_requestsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.company_update_requestsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.company_update_requestsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$company_update_requestsPayload>
          }
          aggregate: {
            args: Prisma.Company_update_requestsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany_update_requests>
          }
          groupBy: {
            args: Prisma.company_update_requestsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Company_update_requestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_update_requestsCountArgs<ExtArgs>,
            result: $Utils.Optional<Company_update_requestsCountAggregateOutputType> | number
          }
        }
      }
      companyupdaterequest_newpaymentoptions: {
        payload: Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>
        fields: Prisma.companyupdaterequest_newpaymentoptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyupdaterequest_newpaymentoptionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyupdaterequest_newpaymentoptionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload>
          }
          findFirst: {
            args: Prisma.companyupdaterequest_newpaymentoptionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyupdaterequest_newpaymentoptionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload>
          }
          findMany: {
            args: Prisma.companyupdaterequest_newpaymentoptionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload>[]
          }
          create: {
            args: Prisma.companyupdaterequest_newpaymentoptionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload>
          }
          createMany: {
            args: Prisma.companyupdaterequest_newpaymentoptionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.companyupdaterequest_newpaymentoptionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload>
          }
          update: {
            args: Prisma.companyupdaterequest_newpaymentoptionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload>
          }
          deleteMany: {
            args: Prisma.companyupdaterequest_newpaymentoptionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.companyupdaterequest_newpaymentoptionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.companyupdaterequest_newpaymentoptionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload>
          }
          aggregate: {
            args: Prisma.Companyupdaterequest_newpaymentoptionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyupdaterequest_newpaymentoptions>
          }
          groupBy: {
            args: Prisma.companyupdaterequest_newpaymentoptionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Companyupdaterequest_newpaymentoptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyupdaterequest_newpaymentoptionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Companyupdaterequest_newpaymentoptionsCountAggregateOutputType> | number
          }
        }
      }
      order_table: {
        payload: Prisma.$order_tablePayload<ExtArgs>
        fields: Prisma.order_tableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_tableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_tableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          findFirst: {
            args: Prisma.order_tableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_tableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          findMany: {
            args: Prisma.order_tableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>[]
          }
          create: {
            args: Prisma.order_tableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          createMany: {
            args: Prisma.order_tableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.order_tableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          update: {
            args: Prisma.order_tableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          deleteMany: {
            args: Prisma.order_tableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.order_tableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.order_tableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          aggregate: {
            args: Prisma.Order_tableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder_table>
          }
          groupBy: {
            args: Prisma.order_tableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Order_tableGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_tableCountArgs<ExtArgs>,
            result: $Utils.Optional<Order_tableCountAggregateOutputType> | number
          }
        }
      }
      orderitem: {
        payload: Prisma.$orderitemPayload<ExtArgs>
        fields: Prisma.orderitemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderitemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderitemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload>
          }
          findFirst: {
            args: Prisma.orderitemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderitemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload>
          }
          findMany: {
            args: Prisma.orderitemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload>[]
          }
          create: {
            args: Prisma.orderitemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload>
          }
          createMany: {
            args: Prisma.orderitemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderitemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload>
          }
          update: {
            args: Prisma.orderitemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload>
          }
          deleteMany: {
            args: Prisma.orderitemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderitemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderitemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderitemPayload>
          }
          aggregate: {
            args: Prisma.OrderitemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderitem>
          }
          groupBy: {
            args: Prisma.orderitemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderitemGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderitemCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderitemCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    account: number
    company_known_companies_company_known_companies_company_idTocompany: number
    company_known_companies_company_known_companies_known_company_idTocompany: number
    notification: number
    company_paymentoptions: number
    order_table_order_table_FROMCOMPANY_IDTocompany: number
    order_table_order_table_TOCOMPANY_IDTocompany: number
    product: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | CompanyCountOutputTypeCountAccountArgs
    company_known_companies_company_known_companies_company_idTocompany?: boolean | CompanyCountOutputTypeCountCompany_known_companies_company_known_companies_company_idTocompanyArgs
    company_known_companies_company_known_companies_known_company_idTocompany?: boolean | CompanyCountOutputTypeCountCompany_known_companies_company_known_companies_known_company_idTocompanyArgs
    notification?: boolean | CompanyCountOutputTypeCountNotificationArgs
    company_paymentoptions?: boolean | CompanyCountOutputTypeCountCompany_paymentoptionsArgs
    order_table_order_table_FROMCOMPANY_IDTocompany?: boolean | CompanyCountOutputTypeCountOrder_table_order_table_FROMCOMPANY_IDTocompanyArgs
    order_table_order_table_TOCOMPANY_IDTocompany?: boolean | CompanyCountOutputTypeCountOrder_table_order_table_TOCOMPANY_IDTocompanyArgs
    product?: boolean | CompanyCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompany_known_companies_company_known_companies_company_idTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_known_companiesWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompany_known_companies_company_known_companies_known_company_idTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_known_companiesWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompany_paymentoptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_paymentoptionsWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountOrder_table_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_tableWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountOrder_table_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_tableWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }



  /**
   * Count Type Order_tableCountOutputType
   */

  export type Order_tableCountOutputType = {
    orderitem: number
  }

  export type Order_tableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderitem?: boolean | Order_tableCountOutputTypeCountOrderitemArgs
  }

  // Custom InputTypes

  /**
   * Order_tableCountOutputType without action
   */
  export type Order_tableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order_tableCountOutputType
     */
    select?: Order_tableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Order_tableCountOutputType without action
   */
  export type Order_tableCountOutputTypeCountOrderitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderitemWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderitem: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderitem?: boolean | ProductCountOutputTypeCountOrderitemArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderitemWhereInput
  }



  /**
   * Models
   */

  /**
   * Model account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    ID: number | null
    ROLE: number | null
    company_id: number | null
  }

  export type AccountSumAggregateOutputType = {
    ID: bigint | null
    ROLE: number | null
    company_id: bigint | null
  }

  export type AccountMinAggregateOutputType = {
    ID: bigint | null
    EMAIL: string | null
    PASSWORD: string | null
    ROLE: number | null
    company_id: bigint | null
  }

  export type AccountMaxAggregateOutputType = {
    ID: bigint | null
    EMAIL: string | null
    PASSWORD: string | null
    ROLE: number | null
    company_id: bigint | null
  }

  export type AccountCountAggregateOutputType = {
    ID: number
    EMAIL: number
    PASSWORD: number
    ROLE: number
    company_id: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    ID?: true
    ROLE?: true
    company_id?: true
  }

  export type AccountSumAggregateInputType = {
    ID?: true
    ROLE?: true
    company_id?: true
  }

  export type AccountMinAggregateInputType = {
    ID?: true
    EMAIL?: true
    PASSWORD?: true
    ROLE?: true
    company_id?: true
  }

  export type AccountMaxAggregateInputType = {
    ID?: true
    EMAIL?: true
    PASSWORD?: true
    ROLE?: true
    company_id?: true
  }

  export type AccountCountAggregateInputType = {
    ID?: true
    EMAIL?: true
    PASSWORD?: true
    ROLE?: true
    company_id?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account to aggregate.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type accountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountWhereInput
    orderBy?: accountOrderByWithAggregationInput | accountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    ID: bigint
    EMAIL: string | null
    PASSWORD: string | null
    ROLE: number | null
    company_id: bigint | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type accountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    EMAIL?: boolean
    PASSWORD?: boolean
    ROLE?: boolean
    company_id?: boolean
    company?: boolean | account$companyArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type accountSelectScalar = {
    ID?: boolean
    EMAIL?: boolean
    PASSWORD?: boolean
    ROLE?: boolean
    company_id?: boolean
  }

  export type accountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | account$companyArgs<ExtArgs>
  }


  export type $accountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "account"
    objects: {
      company: Prisma.$companyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: bigint
      EMAIL: string | null
      PASSWORD: string | null
      ROLE: number | null
      company_id: bigint | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type accountGetPayload<S extends boolean | null | undefined | accountDefaultArgs> = $Result.GetResult<Prisma.$accountPayload, S>

  type accountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface accountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account'], meta: { name: 'account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {accountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends accountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, accountFindUniqueArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {accountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends accountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, accountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends accountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, accountFindFirstArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends accountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, accountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const accountWithIDOnly = await prisma.account.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends accountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, accountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {accountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends accountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, accountCreateArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {accountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends accountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, accountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {accountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends accountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, accountDeleteArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {accountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends accountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, accountUpdateArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {accountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends accountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, accountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends accountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, accountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {accountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends accountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, accountUpsertArgs<ExtArgs>>
    ): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountCountArgs>(
      args?: Subset<T, accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountGroupByArgs['orderBy'] }
        : { orderBy?: accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the account model
   */
  readonly fields: accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends account$companyArgs<ExtArgs> = {}>(args?: Subset<T, account$companyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the account model
   */ 
  interface accountFieldRefs {
    readonly ID: FieldRef<"account", 'BigInt'>
    readonly EMAIL: FieldRef<"account", 'String'>
    readonly PASSWORD: FieldRef<"account", 'String'>
    readonly ROLE: FieldRef<"account", 'Int'>
    readonly company_id: FieldRef<"account", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * account findUnique
   */
  export type accountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }


  /**
   * account findUniqueOrThrow
   */
  export type accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }


  /**
   * account findFirst
   */
  export type accountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * account findFirstOrThrow
   */
  export type accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * account findMany
   */
  export type accountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * account create
   */
  export type accountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * The data needed to create a account.
     */
    data?: XOR<accountCreateInput, accountUncheckedCreateInput>
  }


  /**
   * account createMany
   */
  export type accountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountCreateManyInput | accountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * account update
   */
  export type accountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * The data needed to update a account.
     */
    data: XOR<accountUpdateInput, accountUncheckedUpdateInput>
    /**
     * Choose, which account to update.
     */
    where: accountWhereUniqueInput
  }


  /**
   * account updateMany
   */
  export type accountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountWhereInput
  }


  /**
   * account upsert
   */
  export type accountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * The filter to search for the account to update in case it exists.
     */
    where: accountWhereUniqueInput
    /**
     * In case the account found by the `where` argument doesn't exist, create a new account with this data.
     */
    create: XOR<accountCreateInput, accountUncheckedCreateInput>
    /**
     * In case the account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountUpdateInput, accountUncheckedUpdateInput>
  }


  /**
   * account delete
   */
  export type accountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    /**
     * Filter which account to delete.
     */
    where: accountWhereUniqueInput
  }


  /**
   * account deleteMany
   */
  export type accountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountWhereInput
  }


  /**
   * account.company
   */
  export type account$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * account without action
   */
  export type accountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
  }



  /**
   * Model company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    ID: number | null
    BANKACCOUNTNR: number | null
  }

  export type CompanySumAggregateOutputType = {
    ID: bigint | null
    BANKACCOUNTNR: bigint | null
  }

  export type CompanyMinAggregateOutputType = {
    ID: bigint | null
    BANKACCOUNTNR: bigint | null
    CUSTOMERSTART: Date | null
    ISACTIVE: boolean | null
    LOGO: string | null
    NAME: string | null
    SECTOR: string | null
    VATNUMBER: string | null
    CITY: string | null
    COUNTRY: string | null
    NUMBER: string | null
    STREET: string | null
    ZIPCODE: string | null
    EMAIL: string | null
    PHONENUMBER: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    ID: bigint | null
    BANKACCOUNTNR: bigint | null
    CUSTOMERSTART: Date | null
    ISACTIVE: boolean | null
    LOGO: string | null
    NAME: string | null
    SECTOR: string | null
    VATNUMBER: string | null
    CITY: string | null
    COUNTRY: string | null
    NUMBER: string | null
    STREET: string | null
    ZIPCODE: string | null
    EMAIL: string | null
    PHONENUMBER: string | null
  }

  export type CompanyCountAggregateOutputType = {
    ID: number
    BANKACCOUNTNR: number
    CUSTOMERSTART: number
    ISACTIVE: number
    LOGO: number
    NAME: number
    SECTOR: number
    VATNUMBER: number
    CITY: number
    COUNTRY: number
    NUMBER: number
    STREET: number
    ZIPCODE: number
    EMAIL: number
    PHONENUMBER: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    ID?: true
    BANKACCOUNTNR?: true
  }

  export type CompanySumAggregateInputType = {
    ID?: true
    BANKACCOUNTNR?: true
  }

  export type CompanyMinAggregateInputType = {
    ID?: true
    BANKACCOUNTNR?: true
    CUSTOMERSTART?: true
    ISACTIVE?: true
    LOGO?: true
    NAME?: true
    SECTOR?: true
    VATNUMBER?: true
    CITY?: true
    COUNTRY?: true
    NUMBER?: true
    STREET?: true
    ZIPCODE?: true
    EMAIL?: true
    PHONENUMBER?: true
  }

  export type CompanyMaxAggregateInputType = {
    ID?: true
    BANKACCOUNTNR?: true
    CUSTOMERSTART?: true
    ISACTIVE?: true
    LOGO?: true
    NAME?: true
    SECTOR?: true
    VATNUMBER?: true
    CITY?: true
    COUNTRY?: true
    NUMBER?: true
    STREET?: true
    ZIPCODE?: true
    EMAIL?: true
    PHONENUMBER?: true
  }

  export type CompanyCountAggregateInputType = {
    ID?: true
    BANKACCOUNTNR?: true
    CUSTOMERSTART?: true
    ISACTIVE?: true
    LOGO?: true
    NAME?: true
    SECTOR?: true
    VATNUMBER?: true
    CITY?: true
    COUNTRY?: true
    NUMBER?: true
    STREET?: true
    ZIPCODE?: true
    EMAIL?: true
    PHONENUMBER?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company to aggregate.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type companyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
    orderBy?: companyOrderByWithAggregationInput | companyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: companyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    ID: bigint
    BANKACCOUNTNR: bigint | null
    CUSTOMERSTART: Date | null
    ISACTIVE: boolean | null
    LOGO: string | null
    NAME: string | null
    SECTOR: string | null
    VATNUMBER: string | null
    CITY: string | null
    COUNTRY: string | null
    NUMBER: string | null
    STREET: string | null
    ZIPCODE: string | null
    EMAIL: string | null
    PHONENUMBER: string | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends companyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type companySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    BANKACCOUNTNR?: boolean
    CUSTOMERSTART?: boolean
    ISACTIVE?: boolean
    LOGO?: boolean
    NAME?: boolean
    SECTOR?: boolean
    VATNUMBER?: boolean
    CITY?: boolean
    COUNTRY?: boolean
    NUMBER?: boolean
    STREET?: boolean
    ZIPCODE?: boolean
    EMAIL?: boolean
    PHONENUMBER?: boolean
    account?: boolean | company$accountArgs<ExtArgs>
    company_known_companies_company_known_companies_company_idTocompany?: boolean | company$company_known_companies_company_known_companies_company_idTocompanyArgs<ExtArgs>
    company_known_companies_company_known_companies_known_company_idTocompany?: boolean | company$company_known_companies_company_known_companies_known_company_idTocompanyArgs<ExtArgs>
    notification?: boolean | company$notificationArgs<ExtArgs>
    company_paymentoptions?: boolean | company$company_paymentoptionsArgs<ExtArgs>
    order_table_order_table_FROMCOMPANY_IDTocompany?: boolean | company$order_table_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs>
    order_table_order_table_TOCOMPANY_IDTocompany?: boolean | company$order_table_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs>
    product?: boolean | company$productArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type companySelectScalar = {
    ID?: boolean
    BANKACCOUNTNR?: boolean
    CUSTOMERSTART?: boolean
    ISACTIVE?: boolean
    LOGO?: boolean
    NAME?: boolean
    SECTOR?: boolean
    VATNUMBER?: boolean
    CITY?: boolean
    COUNTRY?: boolean
    NUMBER?: boolean
    STREET?: boolean
    ZIPCODE?: boolean
    EMAIL?: boolean
    PHONENUMBER?: boolean
  }

  export type companyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | company$accountArgs<ExtArgs>
    company_known_companies_company_known_companies_company_idTocompany?: boolean | company$company_known_companies_company_known_companies_company_idTocompanyArgs<ExtArgs>
    company_known_companies_company_known_companies_known_company_idTocompany?: boolean | company$company_known_companies_company_known_companies_known_company_idTocompanyArgs<ExtArgs>
    notification?: boolean | company$notificationArgs<ExtArgs>
    company_paymentoptions?: boolean | company$company_paymentoptionsArgs<ExtArgs>
    order_table_order_table_FROMCOMPANY_IDTocompany?: boolean | company$order_table_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs>
    order_table_order_table_TOCOMPANY_IDTocompany?: boolean | company$order_table_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs>
    product?: boolean | company$productArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $companyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company"
    objects: {
      account: Prisma.$accountPayload<ExtArgs>[]
      company_known_companies_company_known_companies_company_idTocompany: Prisma.$company_known_companiesPayload<ExtArgs>[]
      company_known_companies_company_known_companies_known_company_idTocompany: Prisma.$company_known_companiesPayload<ExtArgs>[]
      notification: Prisma.$notificationPayload<ExtArgs>[]
      company_paymentoptions: Prisma.$company_paymentoptionsPayload<ExtArgs>[]
      order_table_order_table_FROMCOMPANY_IDTocompany: Prisma.$order_tablePayload<ExtArgs>[]
      order_table_order_table_TOCOMPANY_IDTocompany: Prisma.$order_tablePayload<ExtArgs>[]
      product: Prisma.$productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: bigint
      BANKACCOUNTNR: bigint | null
      CUSTOMERSTART: Date | null
      ISACTIVE: boolean | null
      LOGO: string | null
      NAME: string | null
      SECTOR: string | null
      VATNUMBER: string | null
      CITY: string | null
      COUNTRY: string | null
      NUMBER: string | null
      STREET: string | null
      ZIPCODE: string | null
      EMAIL: string | null
      PHONENUMBER: string | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }


  type companyGetPayload<S extends boolean | null | undefined | companyDefaultArgs> = $Result.GetResult<Prisma.$companyPayload, S>

  type companyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<companyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface companyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company'], meta: { name: 'company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {companyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, companyFindUniqueArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {companyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends companyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindFirstArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends companyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const companyWithIDOnly = await prisma.company.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends companyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company.
     * @param {companyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends companyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, companyCreateArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Companies.
     *     @param {companyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {companyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends companyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, companyDeleteArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company.
     * @param {companyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, companyUpdateArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {companyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, companyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {companyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends companyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, companyUpsertArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companyCountArgs>(
      args?: Subset<T, companyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyGroupByArgs['orderBy'] }
        : { orderBy?: companyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company model
   */
  readonly fields: companyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends company$accountArgs<ExtArgs> = {}>(args?: Subset<T, company$accountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, 'findMany'> | Null>;

    company_known_companies_company_known_companies_company_idTocompany<T extends company$company_known_companies_company_known_companies_company_idTocompanyArgs<ExtArgs> = {}>(args?: Subset<T, company$company_known_companies_company_known_companies_company_idTocompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    company_known_companies_company_known_companies_known_company_idTocompany<T extends company$company_known_companies_company_known_companies_known_company_idTocompanyArgs<ExtArgs> = {}>(args?: Subset<T, company$company_known_companies_company_known_companies_known_company_idTocompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    notification<T extends company$notificationArgs<ExtArgs> = {}>(args?: Subset<T, company$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    company_paymentoptions<T extends company$company_paymentoptionsArgs<ExtArgs> = {}>(args?: Subset<T, company$company_paymentoptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    order_table_order_table_FROMCOMPANY_IDTocompany<T extends company$order_table_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs> = {}>(args?: Subset<T, company$order_table_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findMany'> | Null>;

    order_table_order_table_TOCOMPANY_IDTocompany<T extends company$order_table_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs> = {}>(args?: Subset<T, company$order_table_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findMany'> | Null>;

    product<T extends company$productArgs<ExtArgs> = {}>(args?: Subset<T, company$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the company model
   */ 
  interface companyFieldRefs {
    readonly ID: FieldRef<"company", 'BigInt'>
    readonly BANKACCOUNTNR: FieldRef<"company", 'BigInt'>
    readonly CUSTOMERSTART: FieldRef<"company", 'DateTime'>
    readonly ISACTIVE: FieldRef<"company", 'Boolean'>
    readonly LOGO: FieldRef<"company", 'String'>
    readonly NAME: FieldRef<"company", 'String'>
    readonly SECTOR: FieldRef<"company", 'String'>
    readonly VATNUMBER: FieldRef<"company", 'String'>
    readonly CITY: FieldRef<"company", 'String'>
    readonly COUNTRY: FieldRef<"company", 'String'>
    readonly NUMBER: FieldRef<"company", 'String'>
    readonly STREET: FieldRef<"company", 'String'>
    readonly ZIPCODE: FieldRef<"company", 'String'>
    readonly EMAIL: FieldRef<"company", 'String'>
    readonly PHONENUMBER: FieldRef<"company", 'String'>
  }
    

  // Custom InputTypes

  /**
   * company findUnique
   */
  export type companyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company findUniqueOrThrow
   */
  export type companyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company findFirst
   */
  export type companyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * company findFirstOrThrow
   */
  export type companyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * company findMany
   */
  export type companyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * company create
   */
  export type companyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The data needed to create a company.
     */
    data?: XOR<companyCreateInput, companyUncheckedCreateInput>
  }


  /**
   * company createMany
   */
  export type companyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companyCreateManyInput | companyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * company update
   */
  export type companyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The data needed to update a company.
     */
    data: XOR<companyUpdateInput, companyUncheckedUpdateInput>
    /**
     * Choose, which company to update.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company updateMany
   */
  export type companyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companyWhereInput
  }


  /**
   * company upsert
   */
  export type companyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The filter to search for the company to update in case it exists.
     */
    where: companyWhereUniqueInput
    /**
     * In case the company found by the `where` argument doesn't exist, create a new company with this data.
     */
    create: XOR<companyCreateInput, companyUncheckedCreateInput>
    /**
     * In case the company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyUpdateInput, companyUncheckedUpdateInput>
  }


  /**
   * company delete
   */
  export type companyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter which company to delete.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company deleteMany
   */
  export type companyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companyWhereInput
  }


  /**
   * company.account
   */
  export type company$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude<ExtArgs> | null
    where?: accountWhereInput
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    cursor?: accountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * company.company_known_companies_company_known_companies_company_idTocompany
   */
  export type company$company_known_companies_company_known_companies_company_idTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    where?: company_known_companiesWhereInput
    orderBy?: company_known_companiesOrderByWithRelationInput | company_known_companiesOrderByWithRelationInput[]
    cursor?: company_known_companiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_known_companiesScalarFieldEnum | Company_known_companiesScalarFieldEnum[]
  }


  /**
   * company.company_known_companies_company_known_companies_known_company_idTocompany
   */
  export type company$company_known_companies_company_known_companies_known_company_idTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    where?: company_known_companiesWhereInput
    orderBy?: company_known_companiesOrderByWithRelationInput | company_known_companiesOrderByWithRelationInput[]
    cursor?: company_known_companiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_known_companiesScalarFieldEnum | Company_known_companiesScalarFieldEnum[]
  }


  /**
   * company.notification
   */
  export type company$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * company.company_paymentoptions
   */
  export type company$company_paymentoptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    where?: company_paymentoptionsWhereInput
    orderBy?: company_paymentoptionsOrderByWithRelationInput | company_paymentoptionsOrderByWithRelationInput[]
    cursor?: company_paymentoptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_paymentoptionsScalarFieldEnum | Company_paymentoptionsScalarFieldEnum[]
  }


  /**
   * company.order_table_order_table_FROMCOMPANY_IDTocompany
   */
  export type company$order_table_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    where?: order_tableWhereInput
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    cursor?: order_tableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }


  /**
   * company.order_table_order_table_TOCOMPANY_IDTocompany
   */
  export type company$order_table_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    where?: order_tableWhereInput
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    cursor?: order_tableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }


  /**
   * company.product
   */
  export type company$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * company without action
   */
  export type companyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
  }



  /**
   * Model company_known_companies
   */

  export type AggregateCompany_known_companies = {
    _count: Company_known_companiesCountAggregateOutputType | null
    _avg: Company_known_companiesAvgAggregateOutputType | null
    _sum: Company_known_companiesSumAggregateOutputType | null
    _min: Company_known_companiesMinAggregateOutputType | null
    _max: Company_known_companiesMaxAggregateOutputType | null
  }

  export type Company_known_companiesAvgAggregateOutputType = {
    company_id: number | null
    known_company_id: number | null
  }

  export type Company_known_companiesSumAggregateOutputType = {
    company_id: bigint | null
    known_company_id: bigint | null
  }

  export type Company_known_companiesMinAggregateOutputType = {
    company_id: bigint | null
    known_company_id: bigint | null
  }

  export type Company_known_companiesMaxAggregateOutputType = {
    company_id: bigint | null
    known_company_id: bigint | null
  }

  export type Company_known_companiesCountAggregateOutputType = {
    company_id: number
    known_company_id: number
    _all: number
  }


  export type Company_known_companiesAvgAggregateInputType = {
    company_id?: true
    known_company_id?: true
  }

  export type Company_known_companiesSumAggregateInputType = {
    company_id?: true
    known_company_id?: true
  }

  export type Company_known_companiesMinAggregateInputType = {
    company_id?: true
    known_company_id?: true
  }

  export type Company_known_companiesMaxAggregateInputType = {
    company_id?: true
    known_company_id?: true
  }

  export type Company_known_companiesCountAggregateInputType = {
    company_id?: true
    known_company_id?: true
    _all?: true
  }

  export type Company_known_companiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_known_companies to aggregate.
     */
    where?: company_known_companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_known_companies to fetch.
     */
    orderBy?: company_known_companiesOrderByWithRelationInput | company_known_companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_known_companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_known_companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_known_companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_known_companies
    **/
    _count?: true | Company_known_companiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_known_companiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_known_companiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_known_companiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_known_companiesMaxAggregateInputType
  }

  export type GetCompany_known_companiesAggregateType<T extends Company_known_companiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_known_companies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_known_companies[P]>
      : GetScalarType<T[P], AggregateCompany_known_companies[P]>
  }




  export type company_known_companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_known_companiesWhereInput
    orderBy?: company_known_companiesOrderByWithAggregationInput | company_known_companiesOrderByWithAggregationInput[]
    by: Company_known_companiesScalarFieldEnum[] | Company_known_companiesScalarFieldEnum
    having?: company_known_companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_known_companiesCountAggregateInputType | true
    _avg?: Company_known_companiesAvgAggregateInputType
    _sum?: Company_known_companiesSumAggregateInputType
    _min?: Company_known_companiesMinAggregateInputType
    _max?: Company_known_companiesMaxAggregateInputType
  }

  export type Company_known_companiesGroupByOutputType = {
    company_id: bigint
    known_company_id: bigint
    _count: Company_known_companiesCountAggregateOutputType | null
    _avg: Company_known_companiesAvgAggregateOutputType | null
    _sum: Company_known_companiesSumAggregateOutputType | null
    _min: Company_known_companiesMinAggregateOutputType | null
    _max: Company_known_companiesMaxAggregateOutputType | null
  }

  type GetCompany_known_companiesGroupByPayload<T extends company_known_companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_known_companiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_known_companiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_known_companiesGroupByOutputType[P]>
            : GetScalarType<T[P], Company_known_companiesGroupByOutputType[P]>
        }
      >
    >


  export type company_known_companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    known_company_id?: boolean
    company_company_known_companies_company_idTocompany?: boolean | companyDefaultArgs<ExtArgs>
    company_company_known_companies_known_company_idTocompany?: boolean | companyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_known_companies"]>

  export type company_known_companiesSelectScalar = {
    company_id?: boolean
    known_company_id?: boolean
  }

  export type company_known_companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_company_known_companies_company_idTocompany?: boolean | companyDefaultArgs<ExtArgs>
    company_company_known_companies_known_company_idTocompany?: boolean | companyDefaultArgs<ExtArgs>
  }


  export type $company_known_companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_known_companies"
    objects: {
      company_company_known_companies_company_idTocompany: Prisma.$companyPayload<ExtArgs>
      company_company_known_companies_known_company_idTocompany: Prisma.$companyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      company_id: bigint
      known_company_id: bigint
    }, ExtArgs["result"]["company_known_companies"]>
    composites: {}
  }


  type company_known_companiesGetPayload<S extends boolean | null | undefined | company_known_companiesDefaultArgs> = $Result.GetResult<Prisma.$company_known_companiesPayload, S>

  type company_known_companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<company_known_companiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Company_known_companiesCountAggregateInputType | true
    }

  export interface company_known_companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_known_companies'], meta: { name: 'company_known_companies' } }
    /**
     * Find zero or one Company_known_companies that matches the filter.
     * @param {company_known_companiesFindUniqueArgs} args - Arguments to find a Company_known_companies
     * @example
     * // Get one Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends company_known_companiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, company_known_companiesFindUniqueArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company_known_companies that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {company_known_companiesFindUniqueOrThrowArgs} args - Arguments to find a Company_known_companies
     * @example
     * // Get one Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends company_known_companiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, company_known_companiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company_known_companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_known_companiesFindFirstArgs} args - Arguments to find a Company_known_companies
     * @example
     * // Get one Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends company_known_companiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, company_known_companiesFindFirstArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company_known_companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_known_companiesFindFirstOrThrowArgs} args - Arguments to find a Company_known_companies
     * @example
     * // Get one Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends company_known_companiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, company_known_companiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Company_known_companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_known_companiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.findMany()
     * 
     * // Get first 10 Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.findMany({ take: 10 })
     * 
     * // Only select the `company_id`
     * const company_known_companiesWithCompany_idOnly = await prisma.company_known_companies.findMany({ select: { company_id: true } })
     * 
    **/
    findMany<T extends company_known_companiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_known_companiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company_known_companies.
     * @param {company_known_companiesCreateArgs} args - Arguments to create a Company_known_companies.
     * @example
     * // Create one Company_known_companies
     * const Company_known_companies = await prisma.company_known_companies.create({
     *   data: {
     *     // ... data to create a Company_known_companies
     *   }
     * })
     * 
    **/
    create<T extends company_known_companiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, company_known_companiesCreateArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Company_known_companies.
     *     @param {company_known_companiesCreateManyArgs} args - Arguments to create many Company_known_companies.
     *     @example
     *     // Create many Company_known_companies
     *     const company_known_companies = await prisma.company_known_companies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends company_known_companiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_known_companiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company_known_companies.
     * @param {company_known_companiesDeleteArgs} args - Arguments to delete one Company_known_companies.
     * @example
     * // Delete one Company_known_companies
     * const Company_known_companies = await prisma.company_known_companies.delete({
     *   where: {
     *     // ... filter to delete one Company_known_companies
     *   }
     * })
     * 
    **/
    delete<T extends company_known_companiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, company_known_companiesDeleteArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company_known_companies.
     * @param {company_known_companiesUpdateArgs} args - Arguments to update one Company_known_companies.
     * @example
     * // Update one Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends company_known_companiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, company_known_companiesUpdateArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Company_known_companies.
     * @param {company_known_companiesDeleteManyArgs} args - Arguments to filter Company_known_companies to delete.
     * @example
     * // Delete a few Company_known_companies
     * const { count } = await prisma.company_known_companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends company_known_companiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_known_companiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_known_companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_known_companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends company_known_companiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, company_known_companiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company_known_companies.
     * @param {company_known_companiesUpsertArgs} args - Arguments to update or create a Company_known_companies.
     * @example
     * // Update or create a Company_known_companies
     * const company_known_companies = await prisma.company_known_companies.upsert({
     *   create: {
     *     // ... data to create a Company_known_companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_known_companies we want to update
     *   }
     * })
    **/
    upsert<T extends company_known_companiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, company_known_companiesUpsertArgs<ExtArgs>>
    ): Prisma__company_known_companiesClient<$Result.GetResult<Prisma.$company_known_companiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Company_known_companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_known_companiesCountArgs} args - Arguments to filter Company_known_companies to count.
     * @example
     * // Count the number of Company_known_companies
     * const count = await prisma.company_known_companies.count({
     *   where: {
     *     // ... the filter for the Company_known_companies we want to count
     *   }
     * })
    **/
    count<T extends company_known_companiesCountArgs>(
      args?: Subset<T, company_known_companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_known_companiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_known_companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_known_companiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_known_companiesAggregateArgs>(args: Subset<T, Company_known_companiesAggregateArgs>): Prisma.PrismaPromise<GetCompany_known_companiesAggregateType<T>>

    /**
     * Group by Company_known_companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_known_companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_known_companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_known_companiesGroupByArgs['orderBy'] }
        : { orderBy?: company_known_companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_known_companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_known_companiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_known_companies model
   */
  readonly fields: company_known_companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_known_companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_known_companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company_company_known_companies_company_idTocompany<T extends companyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companyDefaultArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company_company_known_companies_known_company_idTocompany<T extends companyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companyDefaultArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the company_known_companies model
   */ 
  interface company_known_companiesFieldRefs {
    readonly company_id: FieldRef<"company_known_companies", 'BigInt'>
    readonly known_company_id: FieldRef<"company_known_companies", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * company_known_companies findUnique
   */
  export type company_known_companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * Filter, which company_known_companies to fetch.
     */
    where: company_known_companiesWhereUniqueInput
  }


  /**
   * company_known_companies findUniqueOrThrow
   */
  export type company_known_companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * Filter, which company_known_companies to fetch.
     */
    where: company_known_companiesWhereUniqueInput
  }


  /**
   * company_known_companies findFirst
   */
  export type company_known_companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * Filter, which company_known_companies to fetch.
     */
    where?: company_known_companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_known_companies to fetch.
     */
    orderBy?: company_known_companiesOrderByWithRelationInput | company_known_companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_known_companies.
     */
    cursor?: company_known_companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_known_companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_known_companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_known_companies.
     */
    distinct?: Company_known_companiesScalarFieldEnum | Company_known_companiesScalarFieldEnum[]
  }


  /**
   * company_known_companies findFirstOrThrow
   */
  export type company_known_companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * Filter, which company_known_companies to fetch.
     */
    where?: company_known_companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_known_companies to fetch.
     */
    orderBy?: company_known_companiesOrderByWithRelationInput | company_known_companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_known_companies.
     */
    cursor?: company_known_companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_known_companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_known_companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_known_companies.
     */
    distinct?: Company_known_companiesScalarFieldEnum | Company_known_companiesScalarFieldEnum[]
  }


  /**
   * company_known_companies findMany
   */
  export type company_known_companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * Filter, which company_known_companies to fetch.
     */
    where?: company_known_companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_known_companies to fetch.
     */
    orderBy?: company_known_companiesOrderByWithRelationInput | company_known_companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_known_companies.
     */
    cursor?: company_known_companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_known_companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_known_companies.
     */
    skip?: number
    distinct?: Company_known_companiesScalarFieldEnum | Company_known_companiesScalarFieldEnum[]
  }


  /**
   * company_known_companies create
   */
  export type company_known_companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a company_known_companies.
     */
    data: XOR<company_known_companiesCreateInput, company_known_companiesUncheckedCreateInput>
  }


  /**
   * company_known_companies createMany
   */
  export type company_known_companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_known_companies.
     */
    data: company_known_companiesCreateManyInput | company_known_companiesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * company_known_companies update
   */
  export type company_known_companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a company_known_companies.
     */
    data: XOR<company_known_companiesUpdateInput, company_known_companiesUncheckedUpdateInput>
    /**
     * Choose, which company_known_companies to update.
     */
    where: company_known_companiesWhereUniqueInput
  }


  /**
   * company_known_companies updateMany
   */
  export type company_known_companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_known_companies.
     */
    data: XOR<company_known_companiesUpdateManyMutationInput, company_known_companiesUncheckedUpdateManyInput>
    /**
     * Filter which company_known_companies to update
     */
    where?: company_known_companiesWhereInput
  }


  /**
   * company_known_companies upsert
   */
  export type company_known_companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the company_known_companies to update in case it exists.
     */
    where: company_known_companiesWhereUniqueInput
    /**
     * In case the company_known_companies found by the `where` argument doesn't exist, create a new company_known_companies with this data.
     */
    create: XOR<company_known_companiesCreateInput, company_known_companiesUncheckedCreateInput>
    /**
     * In case the company_known_companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_known_companiesUpdateInput, company_known_companiesUncheckedUpdateInput>
  }


  /**
   * company_known_companies delete
   */
  export type company_known_companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
    /**
     * Filter which company_known_companies to delete.
     */
    where: company_known_companiesWhereUniqueInput
  }


  /**
   * company_known_companies deleteMany
   */
  export type company_known_companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_known_companies to delete
     */
    where?: company_known_companiesWhereInput
  }


  /**
   * company_known_companies without action
   */
  export type company_known_companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_known_companies
     */
    select?: company_known_companiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_known_companiesInclude<ExtArgs> | null
  }



  /**
   * Model company_paymentoptions
   */

  export type AggregateCompany_paymentoptions = {
    _count: Company_paymentoptionsCountAggregateOutputType | null
    _avg: Company_paymentoptionsAvgAggregateOutputType | null
    _sum: Company_paymentoptionsSumAggregateOutputType | null
    _min: Company_paymentoptionsMinAggregateOutputType | null
    _max: Company_paymentoptionsMaxAggregateOutputType | null
  }

  export type Company_paymentoptionsAvgAggregateOutputType = {
    Company_ID: number | null
  }

  export type Company_paymentoptionsSumAggregateOutputType = {
    Company_ID: bigint | null
  }

  export type Company_paymentoptionsMinAggregateOutputType = {
    Company_ID: bigint | null
    PAYMENTOPTIONS: string | null
  }

  export type Company_paymentoptionsMaxAggregateOutputType = {
    Company_ID: bigint | null
    PAYMENTOPTIONS: string | null
  }

  export type Company_paymentoptionsCountAggregateOutputType = {
    Company_ID: number
    PAYMENTOPTIONS: number
    _all: number
  }


  export type Company_paymentoptionsAvgAggregateInputType = {
    Company_ID?: true
  }

  export type Company_paymentoptionsSumAggregateInputType = {
    Company_ID?: true
  }

  export type Company_paymentoptionsMinAggregateInputType = {
    Company_ID?: true
    PAYMENTOPTIONS?: true
  }

  export type Company_paymentoptionsMaxAggregateInputType = {
    Company_ID?: true
    PAYMENTOPTIONS?: true
  }

  export type Company_paymentoptionsCountAggregateInputType = {
    Company_ID?: true
    PAYMENTOPTIONS?: true
    _all?: true
  }

  export type Company_paymentoptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_paymentoptions to aggregate.
     */
    where?: company_paymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_paymentoptions to fetch.
     */
    orderBy?: company_paymentoptionsOrderByWithRelationInput | company_paymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_paymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_paymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_paymentoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_paymentoptions
    **/
    _count?: true | Company_paymentoptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_paymentoptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_paymentoptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_paymentoptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_paymentoptionsMaxAggregateInputType
  }

  export type GetCompany_paymentoptionsAggregateType<T extends Company_paymentoptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_paymentoptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_paymentoptions[P]>
      : GetScalarType<T[P], AggregateCompany_paymentoptions[P]>
  }




  export type company_paymentoptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_paymentoptionsWhereInput
    orderBy?: company_paymentoptionsOrderByWithAggregationInput | company_paymentoptionsOrderByWithAggregationInput[]
    by: Company_paymentoptionsScalarFieldEnum[] | Company_paymentoptionsScalarFieldEnum
    having?: company_paymentoptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_paymentoptionsCountAggregateInputType | true
    _avg?: Company_paymentoptionsAvgAggregateInputType
    _sum?: Company_paymentoptionsSumAggregateInputType
    _min?: Company_paymentoptionsMinAggregateInputType
    _max?: Company_paymentoptionsMaxAggregateInputType
  }

  export type Company_paymentoptionsGroupByOutputType = {
    Company_ID: bigint
    PAYMENTOPTIONS: string
    _count: Company_paymentoptionsCountAggregateOutputType | null
    _avg: Company_paymentoptionsAvgAggregateOutputType | null
    _sum: Company_paymentoptionsSumAggregateOutputType | null
    _min: Company_paymentoptionsMinAggregateOutputType | null
    _max: Company_paymentoptionsMaxAggregateOutputType | null
  }

  type GetCompany_paymentoptionsGroupByPayload<T extends company_paymentoptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_paymentoptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_paymentoptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_paymentoptionsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_paymentoptionsGroupByOutputType[P]>
        }
      >
    >


  export type company_paymentoptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Company_ID?: boolean
    PAYMENTOPTIONS?: boolean
    company?: boolean | company_paymentoptions$companyArgs<ExtArgs>
  }, ExtArgs["result"]["company_paymentoptions"]>

  export type company_paymentoptionsSelectScalar = {
    Company_ID?: boolean
    PAYMENTOPTIONS?: boolean
  }

  export type company_paymentoptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | company_paymentoptions$companyArgs<ExtArgs>
  }


  export type $company_paymentoptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_paymentoptions"
    objects: {
      company: Prisma.$companyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Company_ID: bigint
      PAYMENTOPTIONS: string
    }, ExtArgs["result"]["company_paymentoptions"]>
    composites: {}
  }


  type company_paymentoptionsGetPayload<S extends boolean | null | undefined | company_paymentoptionsDefaultArgs> = $Result.GetResult<Prisma.$company_paymentoptionsPayload, S>

  type company_paymentoptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<company_paymentoptionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Company_paymentoptionsCountAggregateInputType | true
    }

  export interface company_paymentoptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_paymentoptions'], meta: { name: 'company_paymentoptions' } }
    /**
     * Find zero or one Company_paymentoptions that matches the filter.
     * @param {company_paymentoptionsFindUniqueArgs} args - Arguments to find a Company_paymentoptions
     * @example
     * // Get one Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends company_paymentoptionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, company_paymentoptionsFindUniqueArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company_paymentoptions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {company_paymentoptionsFindUniqueOrThrowArgs} args - Arguments to find a Company_paymentoptions
     * @example
     * // Get one Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends company_paymentoptionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, company_paymentoptionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company_paymentoptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_paymentoptionsFindFirstArgs} args - Arguments to find a Company_paymentoptions
     * @example
     * // Get one Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends company_paymentoptionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, company_paymentoptionsFindFirstArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company_paymentoptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_paymentoptionsFindFirstOrThrowArgs} args - Arguments to find a Company_paymentoptions
     * @example
     * // Get one Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends company_paymentoptionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, company_paymentoptionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Company_paymentoptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_paymentoptionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.findMany()
     * 
     * // Get first 10 Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.findMany({ take: 10 })
     * 
     * // Only select the `Company_ID`
     * const company_paymentoptionsWithCompany_IDOnly = await prisma.company_paymentoptions.findMany({ select: { Company_ID: true } })
     * 
    **/
    findMany<T extends company_paymentoptionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_paymentoptionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company_paymentoptions.
     * @param {company_paymentoptionsCreateArgs} args - Arguments to create a Company_paymentoptions.
     * @example
     * // Create one Company_paymentoptions
     * const Company_paymentoptions = await prisma.company_paymentoptions.create({
     *   data: {
     *     // ... data to create a Company_paymentoptions
     *   }
     * })
     * 
    **/
    create<T extends company_paymentoptionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, company_paymentoptionsCreateArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Company_paymentoptions.
     *     @param {company_paymentoptionsCreateManyArgs} args - Arguments to create many Company_paymentoptions.
     *     @example
     *     // Create many Company_paymentoptions
     *     const company_paymentoptions = await prisma.company_paymentoptions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends company_paymentoptionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_paymentoptionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company_paymentoptions.
     * @param {company_paymentoptionsDeleteArgs} args - Arguments to delete one Company_paymentoptions.
     * @example
     * // Delete one Company_paymentoptions
     * const Company_paymentoptions = await prisma.company_paymentoptions.delete({
     *   where: {
     *     // ... filter to delete one Company_paymentoptions
     *   }
     * })
     * 
    **/
    delete<T extends company_paymentoptionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, company_paymentoptionsDeleteArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company_paymentoptions.
     * @param {company_paymentoptionsUpdateArgs} args - Arguments to update one Company_paymentoptions.
     * @example
     * // Update one Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends company_paymentoptionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, company_paymentoptionsUpdateArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Company_paymentoptions.
     * @param {company_paymentoptionsDeleteManyArgs} args - Arguments to filter Company_paymentoptions to delete.
     * @example
     * // Delete a few Company_paymentoptions
     * const { count } = await prisma.company_paymentoptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends company_paymentoptionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_paymentoptionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_paymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_paymentoptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends company_paymentoptionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, company_paymentoptionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company_paymentoptions.
     * @param {company_paymentoptionsUpsertArgs} args - Arguments to update or create a Company_paymentoptions.
     * @example
     * // Update or create a Company_paymentoptions
     * const company_paymentoptions = await prisma.company_paymentoptions.upsert({
     *   create: {
     *     // ... data to create a Company_paymentoptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_paymentoptions we want to update
     *   }
     * })
    **/
    upsert<T extends company_paymentoptionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, company_paymentoptionsUpsertArgs<ExtArgs>>
    ): Prisma__company_paymentoptionsClient<$Result.GetResult<Prisma.$company_paymentoptionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Company_paymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_paymentoptionsCountArgs} args - Arguments to filter Company_paymentoptions to count.
     * @example
     * // Count the number of Company_paymentoptions
     * const count = await prisma.company_paymentoptions.count({
     *   where: {
     *     // ... the filter for the Company_paymentoptions we want to count
     *   }
     * })
    **/
    count<T extends company_paymentoptionsCountArgs>(
      args?: Subset<T, company_paymentoptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_paymentoptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_paymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_paymentoptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_paymentoptionsAggregateArgs>(args: Subset<T, Company_paymentoptionsAggregateArgs>): Prisma.PrismaPromise<GetCompany_paymentoptionsAggregateType<T>>

    /**
     * Group by Company_paymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_paymentoptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_paymentoptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_paymentoptionsGroupByArgs['orderBy'] }
        : { orderBy?: company_paymentoptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_paymentoptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_paymentoptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_paymentoptions model
   */
  readonly fields: company_paymentoptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_paymentoptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_paymentoptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends company_paymentoptions$companyArgs<ExtArgs> = {}>(args?: Subset<T, company_paymentoptions$companyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the company_paymentoptions model
   */ 
  interface company_paymentoptionsFieldRefs {
    readonly Company_ID: FieldRef<"company_paymentoptions", 'BigInt'>
    readonly PAYMENTOPTIONS: FieldRef<"company_paymentoptions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * company_paymentoptions findUnique
   */
  export type company_paymentoptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_paymentoptions to fetch.
     */
    where: company_paymentoptionsWhereUniqueInput
  }


  /**
   * company_paymentoptions findUniqueOrThrow
   */
  export type company_paymentoptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_paymentoptions to fetch.
     */
    where: company_paymentoptionsWhereUniqueInput
  }


  /**
   * company_paymentoptions findFirst
   */
  export type company_paymentoptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_paymentoptions to fetch.
     */
    where?: company_paymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_paymentoptions to fetch.
     */
    orderBy?: company_paymentoptionsOrderByWithRelationInput | company_paymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_paymentoptions.
     */
    cursor?: company_paymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_paymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_paymentoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_paymentoptions.
     */
    distinct?: Company_paymentoptionsScalarFieldEnum | Company_paymentoptionsScalarFieldEnum[]
  }


  /**
   * company_paymentoptions findFirstOrThrow
   */
  export type company_paymentoptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_paymentoptions to fetch.
     */
    where?: company_paymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_paymentoptions to fetch.
     */
    orderBy?: company_paymentoptionsOrderByWithRelationInput | company_paymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_paymentoptions.
     */
    cursor?: company_paymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_paymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_paymentoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_paymentoptions.
     */
    distinct?: Company_paymentoptionsScalarFieldEnum | Company_paymentoptionsScalarFieldEnum[]
  }


  /**
   * company_paymentoptions findMany
   */
  export type company_paymentoptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_paymentoptions to fetch.
     */
    where?: company_paymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_paymentoptions to fetch.
     */
    orderBy?: company_paymentoptionsOrderByWithRelationInput | company_paymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_paymentoptions.
     */
    cursor?: company_paymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_paymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_paymentoptions.
     */
    skip?: number
    distinct?: Company_paymentoptionsScalarFieldEnum | Company_paymentoptionsScalarFieldEnum[]
  }


  /**
   * company_paymentoptions create
   */
  export type company_paymentoptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a company_paymentoptions.
     */
    data: XOR<company_paymentoptionsCreateInput, company_paymentoptionsUncheckedCreateInput>
  }


  /**
   * company_paymentoptions createMany
   */
  export type company_paymentoptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_paymentoptions.
     */
    data: company_paymentoptionsCreateManyInput | company_paymentoptionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * company_paymentoptions update
   */
  export type company_paymentoptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a company_paymentoptions.
     */
    data: XOR<company_paymentoptionsUpdateInput, company_paymentoptionsUncheckedUpdateInput>
    /**
     * Choose, which company_paymentoptions to update.
     */
    where: company_paymentoptionsWhereUniqueInput
  }


  /**
   * company_paymentoptions updateMany
   */
  export type company_paymentoptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_paymentoptions.
     */
    data: XOR<company_paymentoptionsUpdateManyMutationInput, company_paymentoptionsUncheckedUpdateManyInput>
    /**
     * Filter which company_paymentoptions to update
     */
    where?: company_paymentoptionsWhereInput
  }


  /**
   * company_paymentoptions upsert
   */
  export type company_paymentoptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the company_paymentoptions to update in case it exists.
     */
    where: company_paymentoptionsWhereUniqueInput
    /**
     * In case the company_paymentoptions found by the `where` argument doesn't exist, create a new company_paymentoptions with this data.
     */
    create: XOR<company_paymentoptionsCreateInput, company_paymentoptionsUncheckedCreateInput>
    /**
     * In case the company_paymentoptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_paymentoptionsUpdateInput, company_paymentoptionsUncheckedUpdateInput>
  }


  /**
   * company_paymentoptions delete
   */
  export type company_paymentoptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
    /**
     * Filter which company_paymentoptions to delete.
     */
    where: company_paymentoptionsWhereUniqueInput
  }


  /**
   * company_paymentoptions deleteMany
   */
  export type company_paymentoptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_paymentoptions to delete
     */
    where?: company_paymentoptionsWhereInput
  }


  /**
   * company_paymentoptions.company
   */
  export type company_paymentoptions$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * company_paymentoptions without action
   */
  export type company_paymentoptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_paymentoptions
     */
    select?: company_paymentoptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: company_paymentoptionsInclude<ExtArgs> | null
  }



  /**
   * Model company_update_requests
   */

  export type AggregateCompany_update_requests = {
    _count: Company_update_requestsCountAggregateOutputType | null
    _avg: Company_update_requestsAvgAggregateOutputType | null
    _sum: Company_update_requestsSumAggregateOutputType | null
    _min: Company_update_requestsMinAggregateOutputType | null
    _max: Company_update_requestsMaxAggregateOutputType | null
  }

  export type Company_update_requestsAvgAggregateOutputType = {
    ID: number | null
    NEWBANKACCOUNTNR: number | null
  }

  export type Company_update_requestsSumAggregateOutputType = {
    ID: bigint | null
    NEWBANKACCOUNTNR: bigint | null
  }

  export type Company_update_requestsMinAggregateOutputType = {
    ID: bigint | null
    NEWBANKACCOUNTNR: bigint | null
    NEWCUSTOMEREMAIL: string | null
    NEWCUSTOMERPASSWORD: string | null
    NEWCUSTOMERSTART: Date | null
    NEWLOGO: string | null
    NEWNAME: string | null
    NEWSECTOR: string | null
    NEWSUPPLIEREMAIL: string | null
    NEWSUPPLIERPASSWORD: string | null
    NEWVATNUMBER: string | null
    OLDVATNUMBER: string | null
    REQUESTDATE: Date | null
    CITY: string | null
    COUNTRY: string | null
    NUMBER: string | null
    STREET: string | null
    ZIPCODE: string | null
    EMAIL: string | null
    PHONENUMBER: string | null
  }

  export type Company_update_requestsMaxAggregateOutputType = {
    ID: bigint | null
    NEWBANKACCOUNTNR: bigint | null
    NEWCUSTOMEREMAIL: string | null
    NEWCUSTOMERPASSWORD: string | null
    NEWCUSTOMERSTART: Date | null
    NEWLOGO: string | null
    NEWNAME: string | null
    NEWSECTOR: string | null
    NEWSUPPLIEREMAIL: string | null
    NEWSUPPLIERPASSWORD: string | null
    NEWVATNUMBER: string | null
    OLDVATNUMBER: string | null
    REQUESTDATE: Date | null
    CITY: string | null
    COUNTRY: string | null
    NUMBER: string | null
    STREET: string | null
    ZIPCODE: string | null
    EMAIL: string | null
    PHONENUMBER: string | null
  }

  export type Company_update_requestsCountAggregateOutputType = {
    ID: number
    NEWBANKACCOUNTNR: number
    NEWCUSTOMEREMAIL: number
    NEWCUSTOMERPASSWORD: number
    NEWCUSTOMERSTART: number
    NEWLOGO: number
    NEWNAME: number
    NEWSECTOR: number
    NEWSUPPLIEREMAIL: number
    NEWSUPPLIERPASSWORD: number
    NEWVATNUMBER: number
    OLDVATNUMBER: number
    REQUESTDATE: number
    CITY: number
    COUNTRY: number
    NUMBER: number
    STREET: number
    ZIPCODE: number
    EMAIL: number
    PHONENUMBER: number
    _all: number
  }


  export type Company_update_requestsAvgAggregateInputType = {
    ID?: true
    NEWBANKACCOUNTNR?: true
  }

  export type Company_update_requestsSumAggregateInputType = {
    ID?: true
    NEWBANKACCOUNTNR?: true
  }

  export type Company_update_requestsMinAggregateInputType = {
    ID?: true
    NEWBANKACCOUNTNR?: true
    NEWCUSTOMEREMAIL?: true
    NEWCUSTOMERPASSWORD?: true
    NEWCUSTOMERSTART?: true
    NEWLOGO?: true
    NEWNAME?: true
    NEWSECTOR?: true
    NEWSUPPLIEREMAIL?: true
    NEWSUPPLIERPASSWORD?: true
    NEWVATNUMBER?: true
    OLDVATNUMBER?: true
    REQUESTDATE?: true
    CITY?: true
    COUNTRY?: true
    NUMBER?: true
    STREET?: true
    ZIPCODE?: true
    EMAIL?: true
    PHONENUMBER?: true
  }

  export type Company_update_requestsMaxAggregateInputType = {
    ID?: true
    NEWBANKACCOUNTNR?: true
    NEWCUSTOMEREMAIL?: true
    NEWCUSTOMERPASSWORD?: true
    NEWCUSTOMERSTART?: true
    NEWLOGO?: true
    NEWNAME?: true
    NEWSECTOR?: true
    NEWSUPPLIEREMAIL?: true
    NEWSUPPLIERPASSWORD?: true
    NEWVATNUMBER?: true
    OLDVATNUMBER?: true
    REQUESTDATE?: true
    CITY?: true
    COUNTRY?: true
    NUMBER?: true
    STREET?: true
    ZIPCODE?: true
    EMAIL?: true
    PHONENUMBER?: true
  }

  export type Company_update_requestsCountAggregateInputType = {
    ID?: true
    NEWBANKACCOUNTNR?: true
    NEWCUSTOMEREMAIL?: true
    NEWCUSTOMERPASSWORD?: true
    NEWCUSTOMERSTART?: true
    NEWLOGO?: true
    NEWNAME?: true
    NEWSECTOR?: true
    NEWSUPPLIEREMAIL?: true
    NEWSUPPLIERPASSWORD?: true
    NEWVATNUMBER?: true
    OLDVATNUMBER?: true
    REQUESTDATE?: true
    CITY?: true
    COUNTRY?: true
    NUMBER?: true
    STREET?: true
    ZIPCODE?: true
    EMAIL?: true
    PHONENUMBER?: true
    _all?: true
  }

  export type Company_update_requestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_update_requests to aggregate.
     */
    where?: company_update_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_update_requests to fetch.
     */
    orderBy?: company_update_requestsOrderByWithRelationInput | company_update_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_update_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_update_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_update_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_update_requests
    **/
    _count?: true | Company_update_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_update_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_update_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_update_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_update_requestsMaxAggregateInputType
  }

  export type GetCompany_update_requestsAggregateType<T extends Company_update_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_update_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_update_requests[P]>
      : GetScalarType<T[P], AggregateCompany_update_requests[P]>
  }




  export type company_update_requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_update_requestsWhereInput
    orderBy?: company_update_requestsOrderByWithAggregationInput | company_update_requestsOrderByWithAggregationInput[]
    by: Company_update_requestsScalarFieldEnum[] | Company_update_requestsScalarFieldEnum
    having?: company_update_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_update_requestsCountAggregateInputType | true
    _avg?: Company_update_requestsAvgAggregateInputType
    _sum?: Company_update_requestsSumAggregateInputType
    _min?: Company_update_requestsMinAggregateInputType
    _max?: Company_update_requestsMaxAggregateInputType
  }

  export type Company_update_requestsGroupByOutputType = {
    ID: bigint
    NEWBANKACCOUNTNR: bigint | null
    NEWCUSTOMEREMAIL: string | null
    NEWCUSTOMERPASSWORD: string | null
    NEWCUSTOMERSTART: Date | null
    NEWLOGO: string | null
    NEWNAME: string | null
    NEWSECTOR: string | null
    NEWSUPPLIEREMAIL: string | null
    NEWSUPPLIERPASSWORD: string | null
    NEWVATNUMBER: string | null
    OLDVATNUMBER: string | null
    REQUESTDATE: Date | null
    CITY: string | null
    COUNTRY: string | null
    NUMBER: string | null
    STREET: string | null
    ZIPCODE: string | null
    EMAIL: string | null
    PHONENUMBER: string | null
    _count: Company_update_requestsCountAggregateOutputType | null
    _avg: Company_update_requestsAvgAggregateOutputType | null
    _sum: Company_update_requestsSumAggregateOutputType | null
    _min: Company_update_requestsMinAggregateOutputType | null
    _max: Company_update_requestsMaxAggregateOutputType | null
  }

  type GetCompany_update_requestsGroupByPayload<T extends company_update_requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_update_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_update_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_update_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_update_requestsGroupByOutputType[P]>
        }
      >
    >


  export type company_update_requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    NEWBANKACCOUNTNR?: boolean
    NEWCUSTOMEREMAIL?: boolean
    NEWCUSTOMERPASSWORD?: boolean
    NEWCUSTOMERSTART?: boolean
    NEWLOGO?: boolean
    NEWNAME?: boolean
    NEWSECTOR?: boolean
    NEWSUPPLIEREMAIL?: boolean
    NEWSUPPLIERPASSWORD?: boolean
    NEWVATNUMBER?: boolean
    OLDVATNUMBER?: boolean
    REQUESTDATE?: boolean
    CITY?: boolean
    COUNTRY?: boolean
    NUMBER?: boolean
    STREET?: boolean
    ZIPCODE?: boolean
    EMAIL?: boolean
    PHONENUMBER?: boolean
  }, ExtArgs["result"]["company_update_requests"]>

  export type company_update_requestsSelectScalar = {
    ID?: boolean
    NEWBANKACCOUNTNR?: boolean
    NEWCUSTOMEREMAIL?: boolean
    NEWCUSTOMERPASSWORD?: boolean
    NEWCUSTOMERSTART?: boolean
    NEWLOGO?: boolean
    NEWNAME?: boolean
    NEWSECTOR?: boolean
    NEWSUPPLIEREMAIL?: boolean
    NEWSUPPLIERPASSWORD?: boolean
    NEWVATNUMBER?: boolean
    OLDVATNUMBER?: boolean
    REQUESTDATE?: boolean
    CITY?: boolean
    COUNTRY?: boolean
    NUMBER?: boolean
    STREET?: boolean
    ZIPCODE?: boolean
    EMAIL?: boolean
    PHONENUMBER?: boolean
  }


  export type $company_update_requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_update_requests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: bigint
      NEWBANKACCOUNTNR: bigint | null
      NEWCUSTOMEREMAIL: string | null
      NEWCUSTOMERPASSWORD: string | null
      NEWCUSTOMERSTART: Date | null
      NEWLOGO: string | null
      NEWNAME: string | null
      NEWSECTOR: string | null
      NEWSUPPLIEREMAIL: string | null
      NEWSUPPLIERPASSWORD: string | null
      NEWVATNUMBER: string | null
      OLDVATNUMBER: string | null
      REQUESTDATE: Date | null
      CITY: string | null
      COUNTRY: string | null
      NUMBER: string | null
      STREET: string | null
      ZIPCODE: string | null
      EMAIL: string | null
      PHONENUMBER: string | null
    }, ExtArgs["result"]["company_update_requests"]>
    composites: {}
  }


  type company_update_requestsGetPayload<S extends boolean | null | undefined | company_update_requestsDefaultArgs> = $Result.GetResult<Prisma.$company_update_requestsPayload, S>

  type company_update_requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<company_update_requestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Company_update_requestsCountAggregateInputType | true
    }

  export interface company_update_requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_update_requests'], meta: { name: 'company_update_requests' } }
    /**
     * Find zero or one Company_update_requests that matches the filter.
     * @param {company_update_requestsFindUniqueArgs} args - Arguments to find a Company_update_requests
     * @example
     * // Get one Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends company_update_requestsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, company_update_requestsFindUniqueArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company_update_requests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {company_update_requestsFindUniqueOrThrowArgs} args - Arguments to find a Company_update_requests
     * @example
     * // Get one Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends company_update_requestsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, company_update_requestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company_update_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_update_requestsFindFirstArgs} args - Arguments to find a Company_update_requests
     * @example
     * // Get one Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends company_update_requestsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, company_update_requestsFindFirstArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company_update_requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_update_requestsFindFirstOrThrowArgs} args - Arguments to find a Company_update_requests
     * @example
     * // Get one Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends company_update_requestsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, company_update_requestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Company_update_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_update_requestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.findMany()
     * 
     * // Get first 10 Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const company_update_requestsWithIDOnly = await prisma.company_update_requests.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends company_update_requestsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_update_requestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company_update_requests.
     * @param {company_update_requestsCreateArgs} args - Arguments to create a Company_update_requests.
     * @example
     * // Create one Company_update_requests
     * const Company_update_requests = await prisma.company_update_requests.create({
     *   data: {
     *     // ... data to create a Company_update_requests
     *   }
     * })
     * 
    **/
    create<T extends company_update_requestsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, company_update_requestsCreateArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Company_update_requests.
     *     @param {company_update_requestsCreateManyArgs} args - Arguments to create many Company_update_requests.
     *     @example
     *     // Create many Company_update_requests
     *     const company_update_requests = await prisma.company_update_requests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends company_update_requestsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_update_requestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company_update_requests.
     * @param {company_update_requestsDeleteArgs} args - Arguments to delete one Company_update_requests.
     * @example
     * // Delete one Company_update_requests
     * const Company_update_requests = await prisma.company_update_requests.delete({
     *   where: {
     *     // ... filter to delete one Company_update_requests
     *   }
     * })
     * 
    **/
    delete<T extends company_update_requestsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, company_update_requestsDeleteArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company_update_requests.
     * @param {company_update_requestsUpdateArgs} args - Arguments to update one Company_update_requests.
     * @example
     * // Update one Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends company_update_requestsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, company_update_requestsUpdateArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Company_update_requests.
     * @param {company_update_requestsDeleteManyArgs} args - Arguments to filter Company_update_requests to delete.
     * @example
     * // Delete a few Company_update_requests
     * const { count } = await prisma.company_update_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends company_update_requestsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, company_update_requestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_update_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_update_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends company_update_requestsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, company_update_requestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company_update_requests.
     * @param {company_update_requestsUpsertArgs} args - Arguments to update or create a Company_update_requests.
     * @example
     * // Update or create a Company_update_requests
     * const company_update_requests = await prisma.company_update_requests.upsert({
     *   create: {
     *     // ... data to create a Company_update_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_update_requests we want to update
     *   }
     * })
    **/
    upsert<T extends company_update_requestsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, company_update_requestsUpsertArgs<ExtArgs>>
    ): Prisma__company_update_requestsClient<$Result.GetResult<Prisma.$company_update_requestsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Company_update_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_update_requestsCountArgs} args - Arguments to filter Company_update_requests to count.
     * @example
     * // Count the number of Company_update_requests
     * const count = await prisma.company_update_requests.count({
     *   where: {
     *     // ... the filter for the Company_update_requests we want to count
     *   }
     * })
    **/
    count<T extends company_update_requestsCountArgs>(
      args?: Subset<T, company_update_requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_update_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_update_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_update_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_update_requestsAggregateArgs>(args: Subset<T, Company_update_requestsAggregateArgs>): Prisma.PrismaPromise<GetCompany_update_requestsAggregateType<T>>

    /**
     * Group by Company_update_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_update_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_update_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_update_requestsGroupByArgs['orderBy'] }
        : { orderBy?: company_update_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_update_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_update_requestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_update_requests model
   */
  readonly fields: company_update_requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_update_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_update_requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the company_update_requests model
   */ 
  interface company_update_requestsFieldRefs {
    readonly ID: FieldRef<"company_update_requests", 'BigInt'>
    readonly NEWBANKACCOUNTNR: FieldRef<"company_update_requests", 'BigInt'>
    readonly NEWCUSTOMEREMAIL: FieldRef<"company_update_requests", 'String'>
    readonly NEWCUSTOMERPASSWORD: FieldRef<"company_update_requests", 'String'>
    readonly NEWCUSTOMERSTART: FieldRef<"company_update_requests", 'DateTime'>
    readonly NEWLOGO: FieldRef<"company_update_requests", 'String'>
    readonly NEWNAME: FieldRef<"company_update_requests", 'String'>
    readonly NEWSECTOR: FieldRef<"company_update_requests", 'String'>
    readonly NEWSUPPLIEREMAIL: FieldRef<"company_update_requests", 'String'>
    readonly NEWSUPPLIERPASSWORD: FieldRef<"company_update_requests", 'String'>
    readonly NEWVATNUMBER: FieldRef<"company_update_requests", 'String'>
    readonly OLDVATNUMBER: FieldRef<"company_update_requests", 'String'>
    readonly REQUESTDATE: FieldRef<"company_update_requests", 'DateTime'>
    readonly CITY: FieldRef<"company_update_requests", 'String'>
    readonly COUNTRY: FieldRef<"company_update_requests", 'String'>
    readonly NUMBER: FieldRef<"company_update_requests", 'String'>
    readonly STREET: FieldRef<"company_update_requests", 'String'>
    readonly ZIPCODE: FieldRef<"company_update_requests", 'String'>
    readonly EMAIL: FieldRef<"company_update_requests", 'String'>
    readonly PHONENUMBER: FieldRef<"company_update_requests", 'String'>
  }
    

  // Custom InputTypes

  /**
   * company_update_requests findUnique
   */
  export type company_update_requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * Filter, which company_update_requests to fetch.
     */
    where: company_update_requestsWhereUniqueInput
  }


  /**
   * company_update_requests findUniqueOrThrow
   */
  export type company_update_requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * Filter, which company_update_requests to fetch.
     */
    where: company_update_requestsWhereUniqueInput
  }


  /**
   * company_update_requests findFirst
   */
  export type company_update_requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * Filter, which company_update_requests to fetch.
     */
    where?: company_update_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_update_requests to fetch.
     */
    orderBy?: company_update_requestsOrderByWithRelationInput | company_update_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_update_requests.
     */
    cursor?: company_update_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_update_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_update_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_update_requests.
     */
    distinct?: Company_update_requestsScalarFieldEnum | Company_update_requestsScalarFieldEnum[]
  }


  /**
   * company_update_requests findFirstOrThrow
   */
  export type company_update_requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * Filter, which company_update_requests to fetch.
     */
    where?: company_update_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_update_requests to fetch.
     */
    orderBy?: company_update_requestsOrderByWithRelationInput | company_update_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_update_requests.
     */
    cursor?: company_update_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_update_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_update_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_update_requests.
     */
    distinct?: Company_update_requestsScalarFieldEnum | Company_update_requestsScalarFieldEnum[]
  }


  /**
   * company_update_requests findMany
   */
  export type company_update_requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * Filter, which company_update_requests to fetch.
     */
    where?: company_update_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_update_requests to fetch.
     */
    orderBy?: company_update_requestsOrderByWithRelationInput | company_update_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_update_requests.
     */
    cursor?: company_update_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_update_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_update_requests.
     */
    skip?: number
    distinct?: Company_update_requestsScalarFieldEnum | Company_update_requestsScalarFieldEnum[]
  }


  /**
   * company_update_requests create
   */
  export type company_update_requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * The data needed to create a company_update_requests.
     */
    data?: XOR<company_update_requestsCreateInput, company_update_requestsUncheckedCreateInput>
  }


  /**
   * company_update_requests createMany
   */
  export type company_update_requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_update_requests.
     */
    data: company_update_requestsCreateManyInput | company_update_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * company_update_requests update
   */
  export type company_update_requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * The data needed to update a company_update_requests.
     */
    data: XOR<company_update_requestsUpdateInput, company_update_requestsUncheckedUpdateInput>
    /**
     * Choose, which company_update_requests to update.
     */
    where: company_update_requestsWhereUniqueInput
  }


  /**
   * company_update_requests updateMany
   */
  export type company_update_requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_update_requests.
     */
    data: XOR<company_update_requestsUpdateManyMutationInput, company_update_requestsUncheckedUpdateManyInput>
    /**
     * Filter which company_update_requests to update
     */
    where?: company_update_requestsWhereInput
  }


  /**
   * company_update_requests upsert
   */
  export type company_update_requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * The filter to search for the company_update_requests to update in case it exists.
     */
    where: company_update_requestsWhereUniqueInput
    /**
     * In case the company_update_requests found by the `where` argument doesn't exist, create a new company_update_requests with this data.
     */
    create: XOR<company_update_requestsCreateInput, company_update_requestsUncheckedCreateInput>
    /**
     * In case the company_update_requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_update_requestsUpdateInput, company_update_requestsUncheckedUpdateInput>
  }


  /**
   * company_update_requests delete
   */
  export type company_update_requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
    /**
     * Filter which company_update_requests to delete.
     */
    where: company_update_requestsWhereUniqueInput
  }


  /**
   * company_update_requests deleteMany
   */
  export type company_update_requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_update_requests to delete
     */
    where?: company_update_requestsWhereInput
  }


  /**
   * company_update_requests without action
   */
  export type company_update_requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_update_requests
     */
    select?: company_update_requestsSelect<ExtArgs> | null
  }



  /**
   * Model companyupdaterequest_newpaymentoptions
   */

  export type AggregateCompanyupdaterequest_newpaymentoptions = {
    _count: Companyupdaterequest_newpaymentoptionsCountAggregateOutputType | null
    _avg: Companyupdaterequest_newpaymentoptionsAvgAggregateOutputType | null
    _sum: Companyupdaterequest_newpaymentoptionsSumAggregateOutputType | null
    _min: Companyupdaterequest_newpaymentoptionsMinAggregateOutputType | null
    _max: Companyupdaterequest_newpaymentoptionsMaxAggregateOutputType | null
  }

  export type Companyupdaterequest_newpaymentoptionsAvgAggregateOutputType = {
    CompanyUpdateRequest_ID: number | null
  }

  export type Companyupdaterequest_newpaymentoptionsSumAggregateOutputType = {
    CompanyUpdateRequest_ID: bigint | null
  }

  export type Companyupdaterequest_newpaymentoptionsMinAggregateOutputType = {
    CompanyUpdateRequest_ID: bigint | null
    NEWPAYMENTOPTIONS: string | null
  }

  export type Companyupdaterequest_newpaymentoptionsMaxAggregateOutputType = {
    CompanyUpdateRequest_ID: bigint | null
    NEWPAYMENTOPTIONS: string | null
  }

  export type Companyupdaterequest_newpaymentoptionsCountAggregateOutputType = {
    CompanyUpdateRequest_ID: number
    NEWPAYMENTOPTIONS: number
    _all: number
  }


  export type Companyupdaterequest_newpaymentoptionsAvgAggregateInputType = {
    CompanyUpdateRequest_ID?: true
  }

  export type Companyupdaterequest_newpaymentoptionsSumAggregateInputType = {
    CompanyUpdateRequest_ID?: true
  }

  export type Companyupdaterequest_newpaymentoptionsMinAggregateInputType = {
    CompanyUpdateRequest_ID?: true
    NEWPAYMENTOPTIONS?: true
  }

  export type Companyupdaterequest_newpaymentoptionsMaxAggregateInputType = {
    CompanyUpdateRequest_ID?: true
    NEWPAYMENTOPTIONS?: true
  }

  export type Companyupdaterequest_newpaymentoptionsCountAggregateInputType = {
    CompanyUpdateRequest_ID?: true
    NEWPAYMENTOPTIONS?: true
    _all?: true
  }

  export type Companyupdaterequest_newpaymentoptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyupdaterequest_newpaymentoptions to aggregate.
     */
    where?: companyupdaterequest_newpaymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyupdaterequest_newpaymentoptions to fetch.
     */
    orderBy?: companyupdaterequest_newpaymentoptionsOrderByWithRelationInput | companyupdaterequest_newpaymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyupdaterequest_newpaymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyupdaterequest_newpaymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyupdaterequest_newpaymentoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companyupdaterequest_newpaymentoptions
    **/
    _count?: true | Companyupdaterequest_newpaymentoptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companyupdaterequest_newpaymentoptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companyupdaterequest_newpaymentoptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companyupdaterequest_newpaymentoptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companyupdaterequest_newpaymentoptionsMaxAggregateInputType
  }

  export type GetCompanyupdaterequest_newpaymentoptionsAggregateType<T extends Companyupdaterequest_newpaymentoptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyupdaterequest_newpaymentoptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyupdaterequest_newpaymentoptions[P]>
      : GetScalarType<T[P], AggregateCompanyupdaterequest_newpaymentoptions[P]>
  }




  export type companyupdaterequest_newpaymentoptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyupdaterequest_newpaymentoptionsWhereInput
    orderBy?: companyupdaterequest_newpaymentoptionsOrderByWithAggregationInput | companyupdaterequest_newpaymentoptionsOrderByWithAggregationInput[]
    by: Companyupdaterequest_newpaymentoptionsScalarFieldEnum[] | Companyupdaterequest_newpaymentoptionsScalarFieldEnum
    having?: companyupdaterequest_newpaymentoptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companyupdaterequest_newpaymentoptionsCountAggregateInputType | true
    _avg?: Companyupdaterequest_newpaymentoptionsAvgAggregateInputType
    _sum?: Companyupdaterequest_newpaymentoptionsSumAggregateInputType
    _min?: Companyupdaterequest_newpaymentoptionsMinAggregateInputType
    _max?: Companyupdaterequest_newpaymentoptionsMaxAggregateInputType
  }

  export type Companyupdaterequest_newpaymentoptionsGroupByOutputType = {
    CompanyUpdateRequest_ID: bigint
    NEWPAYMENTOPTIONS: string
    _count: Companyupdaterequest_newpaymentoptionsCountAggregateOutputType | null
    _avg: Companyupdaterequest_newpaymentoptionsAvgAggregateOutputType | null
    _sum: Companyupdaterequest_newpaymentoptionsSumAggregateOutputType | null
    _min: Companyupdaterequest_newpaymentoptionsMinAggregateOutputType | null
    _max: Companyupdaterequest_newpaymentoptionsMaxAggregateOutputType | null
  }

  type GetCompanyupdaterequest_newpaymentoptionsGroupByPayload<T extends companyupdaterequest_newpaymentoptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Companyupdaterequest_newpaymentoptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companyupdaterequest_newpaymentoptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companyupdaterequest_newpaymentoptionsGroupByOutputType[P]>
            : GetScalarType<T[P], Companyupdaterequest_newpaymentoptionsGroupByOutputType[P]>
        }
      >
    >


  export type companyupdaterequest_newpaymentoptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompanyUpdateRequest_ID?: boolean
    NEWPAYMENTOPTIONS?: boolean
  }, ExtArgs["result"]["companyupdaterequest_newpaymentoptions"]>

  export type companyupdaterequest_newpaymentoptionsSelectScalar = {
    CompanyUpdateRequest_ID?: boolean
    NEWPAYMENTOPTIONS?: boolean
  }

  export type companyupdaterequest_newpaymentoptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $companyupdaterequest_newpaymentoptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companyupdaterequest_newpaymentoptions"
    objects: {
      company_update_requests: Prisma.$company_update_requestsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      CompanyUpdateRequest_ID: bigint
      NEWPAYMENTOPTIONS: string
    }, ExtArgs["result"]["companyupdaterequest_newpaymentoptions"]>
    composites: {}
  }


  type companyupdaterequest_newpaymentoptionsGetPayload<S extends boolean | null | undefined | companyupdaterequest_newpaymentoptionsDefaultArgs> = $Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload, S>

  type companyupdaterequest_newpaymentoptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<companyupdaterequest_newpaymentoptionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Companyupdaterequest_newpaymentoptionsCountAggregateInputType | true
    }

  export interface companyupdaterequest_newpaymentoptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companyupdaterequest_newpaymentoptions'], meta: { name: 'companyupdaterequest_newpaymentoptions' } }
    /**
     * Find zero or one Companyupdaterequest_newpaymentoptions that matches the filter.
     * @param {companyupdaterequest_newpaymentoptionsFindUniqueArgs} args - Arguments to find a Companyupdaterequest_newpaymentoptions
     * @example
     * // Get one Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companyupdaterequest_newpaymentoptionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, companyupdaterequest_newpaymentoptionsFindUniqueArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Companyupdaterequest_newpaymentoptions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {companyupdaterequest_newpaymentoptionsFindUniqueOrThrowArgs} args - Arguments to find a Companyupdaterequest_newpaymentoptions
     * @example
     * // Get one Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends companyupdaterequest_newpaymentoptionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, companyupdaterequest_newpaymentoptionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Companyupdaterequest_newpaymentoptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyupdaterequest_newpaymentoptionsFindFirstArgs} args - Arguments to find a Companyupdaterequest_newpaymentoptions
     * @example
     * // Get one Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companyupdaterequest_newpaymentoptionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, companyupdaterequest_newpaymentoptionsFindFirstArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Companyupdaterequest_newpaymentoptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyupdaterequest_newpaymentoptionsFindFirstOrThrowArgs} args - Arguments to find a Companyupdaterequest_newpaymentoptions
     * @example
     * // Get one Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends companyupdaterequest_newpaymentoptionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, companyupdaterequest_newpaymentoptionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Companyupdaterequest_newpaymentoptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyupdaterequest_newpaymentoptionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.findMany()
     * 
     * // Get first 10 Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.findMany({ take: 10 })
     * 
     * // Only select the `CompanyUpdateRequest_ID`
     * const companyupdaterequest_newpaymentoptionsWithCompanyUpdateRequest_IDOnly = await prisma.companyupdaterequest_newpaymentoptions.findMany({ select: { CompanyUpdateRequest_ID: true } })
     * 
    **/
    findMany<T extends companyupdaterequest_newpaymentoptionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyupdaterequest_newpaymentoptionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Companyupdaterequest_newpaymentoptions.
     * @param {companyupdaterequest_newpaymentoptionsCreateArgs} args - Arguments to create a Companyupdaterequest_newpaymentoptions.
     * @example
     * // Create one Companyupdaterequest_newpaymentoptions
     * const Companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.create({
     *   data: {
     *     // ... data to create a Companyupdaterequest_newpaymentoptions
     *   }
     * })
     * 
    **/
    create<T extends companyupdaterequest_newpaymentoptionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, companyupdaterequest_newpaymentoptionsCreateArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Companyupdaterequest_newpaymentoptions.
     *     @param {companyupdaterequest_newpaymentoptionsCreateManyArgs} args - Arguments to create many Companyupdaterequest_newpaymentoptions.
     *     @example
     *     // Create many Companyupdaterequest_newpaymentoptions
     *     const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companyupdaterequest_newpaymentoptionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyupdaterequest_newpaymentoptionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Companyupdaterequest_newpaymentoptions.
     * @param {companyupdaterequest_newpaymentoptionsDeleteArgs} args - Arguments to delete one Companyupdaterequest_newpaymentoptions.
     * @example
     * // Delete one Companyupdaterequest_newpaymentoptions
     * const Companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.delete({
     *   where: {
     *     // ... filter to delete one Companyupdaterequest_newpaymentoptions
     *   }
     * })
     * 
    **/
    delete<T extends companyupdaterequest_newpaymentoptionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, companyupdaterequest_newpaymentoptionsDeleteArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Companyupdaterequest_newpaymentoptions.
     * @param {companyupdaterequest_newpaymentoptionsUpdateArgs} args - Arguments to update one Companyupdaterequest_newpaymentoptions.
     * @example
     * // Update one Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companyupdaterequest_newpaymentoptionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, companyupdaterequest_newpaymentoptionsUpdateArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Companyupdaterequest_newpaymentoptions.
     * @param {companyupdaterequest_newpaymentoptionsDeleteManyArgs} args - Arguments to filter Companyupdaterequest_newpaymentoptions to delete.
     * @example
     * // Delete a few Companyupdaterequest_newpaymentoptions
     * const { count } = await prisma.companyupdaterequest_newpaymentoptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companyupdaterequest_newpaymentoptionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyupdaterequest_newpaymentoptionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companyupdaterequest_newpaymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyupdaterequest_newpaymentoptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companyupdaterequest_newpaymentoptionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, companyupdaterequest_newpaymentoptionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Companyupdaterequest_newpaymentoptions.
     * @param {companyupdaterequest_newpaymentoptionsUpsertArgs} args - Arguments to update or create a Companyupdaterequest_newpaymentoptions.
     * @example
     * // Update or create a Companyupdaterequest_newpaymentoptions
     * const companyupdaterequest_newpaymentoptions = await prisma.companyupdaterequest_newpaymentoptions.upsert({
     *   create: {
     *     // ... data to create a Companyupdaterequest_newpaymentoptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companyupdaterequest_newpaymentoptions we want to update
     *   }
     * })
    **/
    upsert<T extends companyupdaterequest_newpaymentoptionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, companyupdaterequest_newpaymentoptionsUpsertArgs<ExtArgs>>
    ): Prisma__companyupdaterequest_newpaymentoptionsClient<$Result.GetResult<Prisma.$companyupdaterequest_newpaymentoptionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Companyupdaterequest_newpaymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyupdaterequest_newpaymentoptionsCountArgs} args - Arguments to filter Companyupdaterequest_newpaymentoptions to count.
     * @example
     * // Count the number of Companyupdaterequest_newpaymentoptions
     * const count = await prisma.companyupdaterequest_newpaymentoptions.count({
     *   where: {
     *     // ... the filter for the Companyupdaterequest_newpaymentoptions we want to count
     *   }
     * })
    **/
    count<T extends companyupdaterequest_newpaymentoptionsCountArgs>(
      args?: Subset<T, companyupdaterequest_newpaymentoptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companyupdaterequest_newpaymentoptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companyupdaterequest_newpaymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companyupdaterequest_newpaymentoptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companyupdaterequest_newpaymentoptionsAggregateArgs>(args: Subset<T, Companyupdaterequest_newpaymentoptionsAggregateArgs>): Prisma.PrismaPromise<GetCompanyupdaterequest_newpaymentoptionsAggregateType<T>>

    /**
     * Group by Companyupdaterequest_newpaymentoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyupdaterequest_newpaymentoptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyupdaterequest_newpaymentoptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyupdaterequest_newpaymentoptionsGroupByArgs['orderBy'] }
        : { orderBy?: companyupdaterequest_newpaymentoptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyupdaterequest_newpaymentoptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyupdaterequest_newpaymentoptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companyupdaterequest_newpaymentoptions model
   */
  readonly fields: companyupdaterequest_newpaymentoptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companyupdaterequest_newpaymentoptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyupdaterequest_newpaymentoptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the companyupdaterequest_newpaymentoptions model
   */ 
  interface companyupdaterequest_newpaymentoptionsFieldRefs {
    readonly CompanyUpdateRequest_ID: FieldRef<"companyupdaterequest_newpaymentoptions", 'BigInt'>
    readonly NEWPAYMENTOPTIONS: FieldRef<"companyupdaterequest_newpaymentoptions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * companyupdaterequest_newpaymentoptions findUnique
   */
  export type companyupdaterequest_newpaymentoptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * Filter, which companyupdaterequest_newpaymentoptions to fetch.
     */
    where: companyupdaterequest_newpaymentoptionsWhereUniqueInput
  }


  /**
   * companyupdaterequest_newpaymentoptions findUniqueOrThrow
   */
  export type companyupdaterequest_newpaymentoptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * Filter, which companyupdaterequest_newpaymentoptions to fetch.
     */
    where: companyupdaterequest_newpaymentoptionsWhereUniqueInput
  }


  /**
   * companyupdaterequest_newpaymentoptions findFirst
   */
  export type companyupdaterequest_newpaymentoptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * Filter, which companyupdaterequest_newpaymentoptions to fetch.
     */
    where?: companyupdaterequest_newpaymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyupdaterequest_newpaymentoptions to fetch.
     */
    orderBy?: companyupdaterequest_newpaymentoptionsOrderByWithRelationInput | companyupdaterequest_newpaymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyupdaterequest_newpaymentoptions.
     */
    cursor?: companyupdaterequest_newpaymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyupdaterequest_newpaymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyupdaterequest_newpaymentoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyupdaterequest_newpaymentoptions.
     */
    distinct?: Companyupdaterequest_newpaymentoptionsScalarFieldEnum | Companyupdaterequest_newpaymentoptionsScalarFieldEnum[]
  }


  /**
   * companyupdaterequest_newpaymentoptions findFirstOrThrow
   */
  export type companyupdaterequest_newpaymentoptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * Filter, which companyupdaterequest_newpaymentoptions to fetch.
     */
    where?: companyupdaterequest_newpaymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyupdaterequest_newpaymentoptions to fetch.
     */
    orderBy?: companyupdaterequest_newpaymentoptionsOrderByWithRelationInput | companyupdaterequest_newpaymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyupdaterequest_newpaymentoptions.
     */
    cursor?: companyupdaterequest_newpaymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyupdaterequest_newpaymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyupdaterequest_newpaymentoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyupdaterequest_newpaymentoptions.
     */
    distinct?: Companyupdaterequest_newpaymentoptionsScalarFieldEnum | Companyupdaterequest_newpaymentoptionsScalarFieldEnum[]
  }


  /**
   * companyupdaterequest_newpaymentoptions findMany
   */
  export type companyupdaterequest_newpaymentoptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * Filter, which companyupdaterequest_newpaymentoptions to fetch.
     */
    where?: companyupdaterequest_newpaymentoptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyupdaterequest_newpaymentoptions to fetch.
     */
    orderBy?: companyupdaterequest_newpaymentoptionsOrderByWithRelationInput | companyupdaterequest_newpaymentoptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companyupdaterequest_newpaymentoptions.
     */
    cursor?: companyupdaterequest_newpaymentoptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyupdaterequest_newpaymentoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyupdaterequest_newpaymentoptions.
     */
    skip?: number
    distinct?: Companyupdaterequest_newpaymentoptionsScalarFieldEnum | Companyupdaterequest_newpaymentoptionsScalarFieldEnum[]
  }


  /**
   * companyupdaterequest_newpaymentoptions create
   */
  export type companyupdaterequest_newpaymentoptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * The data needed to create a companyupdaterequest_newpaymentoptions.
     */
    data: XOR<companyupdaterequest_newpaymentoptionsCreateInput, companyupdaterequest_newpaymentoptionsUncheckedCreateInput>
  }


  /**
   * companyupdaterequest_newpaymentoptions createMany
   */
  export type companyupdaterequest_newpaymentoptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companyupdaterequest_newpaymentoptions.
     */
    data: companyupdaterequest_newpaymentoptionsCreateManyInput | companyupdaterequest_newpaymentoptionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * companyupdaterequest_newpaymentoptions update
   */
  export type companyupdaterequest_newpaymentoptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * The data needed to update a companyupdaterequest_newpaymentoptions.
     */
    data: XOR<companyupdaterequest_newpaymentoptionsUpdateInput, companyupdaterequest_newpaymentoptionsUncheckedUpdateInput>
    /**
     * Choose, which companyupdaterequest_newpaymentoptions to update.
     */
    where: companyupdaterequest_newpaymentoptionsWhereUniqueInput
  }


  /**
   * companyupdaterequest_newpaymentoptions updateMany
   */
  export type companyupdaterequest_newpaymentoptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companyupdaterequest_newpaymentoptions.
     */
    data: XOR<companyupdaterequest_newpaymentoptionsUpdateManyMutationInput, companyupdaterequest_newpaymentoptionsUncheckedUpdateManyInput>
    /**
     * Filter which companyupdaterequest_newpaymentoptions to update
     */
    where?: companyupdaterequest_newpaymentoptionsWhereInput
  }


  /**
   * companyupdaterequest_newpaymentoptions upsert
   */
  export type companyupdaterequest_newpaymentoptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * The filter to search for the companyupdaterequest_newpaymentoptions to update in case it exists.
     */
    where: companyupdaterequest_newpaymentoptionsWhereUniqueInput
    /**
     * In case the companyupdaterequest_newpaymentoptions found by the `where` argument doesn't exist, create a new companyupdaterequest_newpaymentoptions with this data.
     */
    create: XOR<companyupdaterequest_newpaymentoptionsCreateInput, companyupdaterequest_newpaymentoptionsUncheckedCreateInput>
    /**
     * In case the companyupdaterequest_newpaymentoptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyupdaterequest_newpaymentoptionsUpdateInput, companyupdaterequest_newpaymentoptionsUncheckedUpdateInput>
  }


  /**
   * companyupdaterequest_newpaymentoptions delete
   */
  export type companyupdaterequest_newpaymentoptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
    /**
     * Filter which companyupdaterequest_newpaymentoptions to delete.
     */
    where: companyupdaterequest_newpaymentoptionsWhereUniqueInput
  }


  /**
   * companyupdaterequest_newpaymentoptions deleteMany
   */
  export type companyupdaterequest_newpaymentoptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyupdaterequest_newpaymentoptions to delete
     */
    where?: companyupdaterequest_newpaymentoptionsWhereInput
  }


  /**
   * companyupdaterequest_newpaymentoptions without action
   */
  export type companyupdaterequest_newpaymentoptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyupdaterequest_newpaymentoptions
     */
    select?: companyupdaterequest_newpaymentoptionsSelect<ExtArgs> | null
  }



  /**
   * Model order_table
   */

  export type AggregateOrder_table = {
    _count: Order_tableCountAggregateOutputType | null
    _avg: Order_tableAvgAggregateOutputType | null
    _sum: Order_tableSumAggregateOutputType | null
    _min: Order_tableMinAggregateOutputType | null
    _max: Order_tableMaxAggregateOutputType | null
  }

  export type Order_tableAvgAggregateOutputType = {
    ID: number | null
    NETAMOUNT: number | null
    ORDERSTATUS: number | null
    PAYMENTSTATUS: number | null
    TAXAMOUNT: number | null
    TOTALAMOUNT: number | null
    FROMCOMPANY_ID: number | null
    TOCOMPANY_ID: number | null
  }

  export type Order_tableSumAggregateOutputType = {
    ID: bigint | null
    NETAMOUNT: number | null
    ORDERSTATUS: number | null
    PAYMENTSTATUS: number | null
    TAXAMOUNT: number | null
    TOTALAMOUNT: number | null
    FROMCOMPANY_ID: bigint | null
    TOCOMPANY_ID: bigint | null
  }

  export type Order_tableMinAggregateOutputType = {
    ID: bigint | null
    CURRENCY: string | null
    DATE: string | null
    LASTPAYMENTREMINDER: string | null
    NAME: string | null
    NETAMOUNT: number | null
    ORDERDATETIME: Date | null
    ORDERID: string | null
    ORDERREFERENCE: string | null
    ORDERSTATUS: number | null
    PAYMENTSTATUS: number | null
    TAXAMOUNT: number | null
    TOTALAMOUNT: number | null
    FROMCOMPANY_ID: bigint | null
    TOCOMPANY_ID: bigint | null
  }

  export type Order_tableMaxAggregateOutputType = {
    ID: bigint | null
    CURRENCY: string | null
    DATE: string | null
    LASTPAYMENTREMINDER: string | null
    NAME: string | null
    NETAMOUNT: number | null
    ORDERDATETIME: Date | null
    ORDERID: string | null
    ORDERREFERENCE: string | null
    ORDERSTATUS: number | null
    PAYMENTSTATUS: number | null
    TAXAMOUNT: number | null
    TOTALAMOUNT: number | null
    FROMCOMPANY_ID: bigint | null
    TOCOMPANY_ID: bigint | null
  }

  export type Order_tableCountAggregateOutputType = {
    ID: number
    CURRENCY: number
    DATE: number
    LASTPAYMENTREMINDER: number
    NAME: number
    NETAMOUNT: number
    ORDERDATETIME: number
    ORDERID: number
    ORDERREFERENCE: number
    ORDERSTATUS: number
    PAYMENTSTATUS: number
    TAXAMOUNT: number
    TOTALAMOUNT: number
    FROMCOMPANY_ID: number
    TOCOMPANY_ID: number
    _all: number
  }


  export type Order_tableAvgAggregateInputType = {
    ID?: true
    NETAMOUNT?: true
    ORDERSTATUS?: true
    PAYMENTSTATUS?: true
    TAXAMOUNT?: true
    TOTALAMOUNT?: true
    FROMCOMPANY_ID?: true
    TOCOMPANY_ID?: true
  }

  export type Order_tableSumAggregateInputType = {
    ID?: true
    NETAMOUNT?: true
    ORDERSTATUS?: true
    PAYMENTSTATUS?: true
    TAXAMOUNT?: true
    TOTALAMOUNT?: true
    FROMCOMPANY_ID?: true
    TOCOMPANY_ID?: true
  }

  export type Order_tableMinAggregateInputType = {
    ID?: true
    CURRENCY?: true
    DATE?: true
    LASTPAYMENTREMINDER?: true
    NAME?: true
    NETAMOUNT?: true
    ORDERDATETIME?: true
    ORDERID?: true
    ORDERREFERENCE?: true
    ORDERSTATUS?: true
    PAYMENTSTATUS?: true
    TAXAMOUNT?: true
    TOTALAMOUNT?: true
    FROMCOMPANY_ID?: true
    TOCOMPANY_ID?: true
  }

  export type Order_tableMaxAggregateInputType = {
    ID?: true
    CURRENCY?: true
    DATE?: true
    LASTPAYMENTREMINDER?: true
    NAME?: true
    NETAMOUNT?: true
    ORDERDATETIME?: true
    ORDERID?: true
    ORDERREFERENCE?: true
    ORDERSTATUS?: true
    PAYMENTSTATUS?: true
    TAXAMOUNT?: true
    TOTALAMOUNT?: true
    FROMCOMPANY_ID?: true
    TOCOMPANY_ID?: true
  }

  export type Order_tableCountAggregateInputType = {
    ID?: true
    CURRENCY?: true
    DATE?: true
    LASTPAYMENTREMINDER?: true
    NAME?: true
    NETAMOUNT?: true
    ORDERDATETIME?: true
    ORDERID?: true
    ORDERREFERENCE?: true
    ORDERSTATUS?: true
    PAYMENTSTATUS?: true
    TAXAMOUNT?: true
    TOTALAMOUNT?: true
    FROMCOMPANY_ID?: true
    TOCOMPANY_ID?: true
    _all?: true
  }

  export type Order_tableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_table to aggregate.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_tables
    **/
    _count?: true | Order_tableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_tableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_tableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_tableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_tableMaxAggregateInputType
  }

  export type GetOrder_tableAggregateType<T extends Order_tableAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_table]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_table[P]>
      : GetScalarType<T[P], AggregateOrder_table[P]>
  }




  export type order_tableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_tableWhereInput
    orderBy?: order_tableOrderByWithAggregationInput | order_tableOrderByWithAggregationInput[]
    by: Order_tableScalarFieldEnum[] | Order_tableScalarFieldEnum
    having?: order_tableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_tableCountAggregateInputType | true
    _avg?: Order_tableAvgAggregateInputType
    _sum?: Order_tableSumAggregateInputType
    _min?: Order_tableMinAggregateInputType
    _max?: Order_tableMaxAggregateInputType
  }

  export type Order_tableGroupByOutputType = {
    ID: bigint
    CURRENCY: string | null
    DATE: string | null
    LASTPAYMENTREMINDER: string | null
    NAME: string | null
    NETAMOUNT: number | null
    ORDERDATETIME: Date | null
    ORDERID: string | null
    ORDERREFERENCE: string | null
    ORDERSTATUS: number | null
    PAYMENTSTATUS: number | null
    TAXAMOUNT: number | null
    TOTALAMOUNT: number | null
    FROMCOMPANY_ID: bigint | null
    TOCOMPANY_ID: bigint | null
    _count: Order_tableCountAggregateOutputType | null
    _avg: Order_tableAvgAggregateOutputType | null
    _sum: Order_tableSumAggregateOutputType | null
    _min: Order_tableMinAggregateOutputType | null
    _max: Order_tableMaxAggregateOutputType | null
  }

  type GetOrder_tableGroupByPayload<T extends order_tableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_tableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_tableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_tableGroupByOutputType[P]>
            : GetScalarType<T[P], Order_tableGroupByOutputType[P]>
        }
      >
    >


  export type order_tableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CURRENCY?: boolean
    DATE?: boolean
    LASTPAYMENTREMINDER?: boolean
    NAME?: boolean
    NETAMOUNT?: boolean
    ORDERDATETIME?: boolean
    ORDERID?: boolean
    ORDERREFERENCE?: boolean
    ORDERSTATUS?: boolean
    PAYMENTSTATUS?: boolean
    TAXAMOUNT?: boolean
    TOTALAMOUNT?: boolean
    FROMCOMPANY_ID?: boolean
    TOCOMPANY_ID?: boolean
    company_order_table_FROMCOMPANY_IDTocompany?: boolean | order_table$company_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs>
    company_order_table_TOCOMPANY_IDTocompany?: boolean | order_table$company_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs>
    orderitem?: boolean | order_table$orderitemArgs<ExtArgs>
    _count?: boolean | Order_tableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_table"]>

  export type order_tableSelectScalar = {
    ID?: boolean
    CURRENCY?: boolean
    DATE?: boolean
    LASTPAYMENTREMINDER?: boolean
    NAME?: boolean
    NETAMOUNT?: boolean
    ORDERDATETIME?: boolean
    ORDERID?: boolean
    ORDERREFERENCE?: boolean
    ORDERSTATUS?: boolean
    PAYMENTSTATUS?: boolean
    TAXAMOUNT?: boolean
    TOTALAMOUNT?: boolean
    FROMCOMPANY_ID?: boolean
    TOCOMPANY_ID?: boolean
  }

  export type order_tableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_order_table_FROMCOMPANY_IDTocompany?: boolean | order_table$company_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs>
    company_order_table_TOCOMPANY_IDTocompany?: boolean | order_table$company_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs>
    orderitem?: boolean | order_table$orderitemArgs<ExtArgs>
    _count?: boolean | Order_tableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $order_tablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_table"
    objects: {
      company_order_table_FROMCOMPANY_IDTocompany: Prisma.$companyPayload<ExtArgs> | null
      company_order_table_TOCOMPANY_IDTocompany: Prisma.$companyPayload<ExtArgs> | null
      orderitem: Prisma.$orderitemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: bigint
      CURRENCY: string | null
      DATE: string | null
      LASTPAYMENTREMINDER: string | null
      NAME: string | null
      NETAMOUNT: number | null
      ORDERDATETIME: Date | null
      ORDERID: string | null
      ORDERREFERENCE: string | null
      ORDERSTATUS: number | null
      PAYMENTSTATUS: number | null
      TAXAMOUNT: number | null
      TOTALAMOUNT: number | null
      FROMCOMPANY_ID: bigint | null
      TOCOMPANY_ID: bigint | null
    }, ExtArgs["result"]["order_table"]>
    composites: {}
  }


  type order_tableGetPayload<S extends boolean | null | undefined | order_tableDefaultArgs> = $Result.GetResult<Prisma.$order_tablePayload, S>

  type order_tableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_tableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Order_tableCountAggregateInputType | true
    }

  export interface order_tableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_table'], meta: { name: 'order_table' } }
    /**
     * Find zero or one Order_table that matches the filter.
     * @param {order_tableFindUniqueArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends order_tableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, order_tableFindUniqueArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order_table that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {order_tableFindUniqueOrThrowArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends order_tableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_tableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order_table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableFindFirstArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends order_tableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, order_tableFindFirstArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order_table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableFindFirstOrThrowArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends order_tableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_tableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Order_tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_tables
     * const order_tables = await prisma.order_table.findMany()
     * 
     * // Get first 10 Order_tables
     * const order_tables = await prisma.order_table.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const order_tableWithIDOnly = await prisma.order_table.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends order_tableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_tableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order_table.
     * @param {order_tableCreateArgs} args - Arguments to create a Order_table.
     * @example
     * // Create one Order_table
     * const Order_table = await prisma.order_table.create({
     *   data: {
     *     // ... data to create a Order_table
     *   }
     * })
     * 
    **/
    create<T extends order_tableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, order_tableCreateArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Order_tables.
     *     @param {order_tableCreateManyArgs} args - Arguments to create many Order_tables.
     *     @example
     *     // Create many Order_tables
     *     const order_table = await prisma.order_table.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends order_tableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_tableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order_table.
     * @param {order_tableDeleteArgs} args - Arguments to delete one Order_table.
     * @example
     * // Delete one Order_table
     * const Order_table = await prisma.order_table.delete({
     *   where: {
     *     // ... filter to delete one Order_table
     *   }
     * })
     * 
    **/
    delete<T extends order_tableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, order_tableDeleteArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order_table.
     * @param {order_tableUpdateArgs} args - Arguments to update one Order_table.
     * @example
     * // Update one Order_table
     * const order_table = await prisma.order_table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends order_tableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, order_tableUpdateArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Order_tables.
     * @param {order_tableDeleteManyArgs} args - Arguments to filter Order_tables to delete.
     * @example
     * // Delete a few Order_tables
     * const { count } = await prisma.order_table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends order_tableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_tableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_tables
     * const order_table = await prisma.order_table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends order_tableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, order_tableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_table.
     * @param {order_tableUpsertArgs} args - Arguments to update or create a Order_table.
     * @example
     * // Update or create a Order_table
     * const order_table = await prisma.order_table.upsert({
     *   create: {
     *     // ... data to create a Order_table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_table we want to update
     *   }
     * })
    **/
    upsert<T extends order_tableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, order_tableUpsertArgs<ExtArgs>>
    ): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Order_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableCountArgs} args - Arguments to filter Order_tables to count.
     * @example
     * // Count the number of Order_tables
     * const count = await prisma.order_table.count({
     *   where: {
     *     // ... the filter for the Order_tables we want to count
     *   }
     * })
    **/
    count<T extends order_tableCountArgs>(
      args?: Subset<T, order_tableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_tableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_tableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_tableAggregateArgs>(args: Subset<T, Order_tableAggregateArgs>): Prisma.PrismaPromise<GetOrder_tableAggregateType<T>>

    /**
     * Group by Order_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_tableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_tableGroupByArgs['orderBy'] }
        : { orderBy?: order_tableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_tableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_tableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_table model
   */
  readonly fields: order_tableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_tableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company_order_table_FROMCOMPANY_IDTocompany<T extends order_table$company_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs> = {}>(args?: Subset<T, order_table$company_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    company_order_table_TOCOMPANY_IDTocompany<T extends order_table$company_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs> = {}>(args?: Subset<T, order_table$company_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    orderitem<T extends order_table$orderitemArgs<ExtArgs> = {}>(args?: Subset<T, order_table$orderitemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the order_table model
   */ 
  interface order_tableFieldRefs {
    readonly ID: FieldRef<"order_table", 'BigInt'>
    readonly CURRENCY: FieldRef<"order_table", 'String'>
    readonly DATE: FieldRef<"order_table", 'String'>
    readonly LASTPAYMENTREMINDER: FieldRef<"order_table", 'String'>
    readonly NAME: FieldRef<"order_table", 'String'>
    readonly NETAMOUNT: FieldRef<"order_table", 'Float'>
    readonly ORDERDATETIME: FieldRef<"order_table", 'DateTime'>
    readonly ORDERID: FieldRef<"order_table", 'String'>
    readonly ORDERREFERENCE: FieldRef<"order_table", 'String'>
    readonly ORDERSTATUS: FieldRef<"order_table", 'Int'>
    readonly PAYMENTSTATUS: FieldRef<"order_table", 'Int'>
    readonly TAXAMOUNT: FieldRef<"order_table", 'Float'>
    readonly TOTALAMOUNT: FieldRef<"order_table", 'Float'>
    readonly FROMCOMPANY_ID: FieldRef<"order_table", 'BigInt'>
    readonly TOCOMPANY_ID: FieldRef<"order_table", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * order_table findUnique
   */
  export type order_tableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where: order_tableWhereUniqueInput
  }


  /**
   * order_table findUniqueOrThrow
   */
  export type order_tableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where: order_tableWhereUniqueInput
  }


  /**
   * order_table findFirst
   */
  export type order_tableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_tables.
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_tables.
     */
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }


  /**
   * order_table findFirstOrThrow
   */
  export type order_tableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_tables.
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_tables.
     */
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }


  /**
   * order_table findMany
   */
  export type order_tableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * Filter, which order_tables to fetch.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_tables.
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }


  /**
   * order_table create
   */
  export type order_tableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * The data needed to create a order_table.
     */
    data?: XOR<order_tableCreateInput, order_tableUncheckedCreateInput>
  }


  /**
   * order_table createMany
   */
  export type order_tableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_tables.
     */
    data: order_tableCreateManyInput | order_tableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * order_table update
   */
  export type order_tableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * The data needed to update a order_table.
     */
    data: XOR<order_tableUpdateInput, order_tableUncheckedUpdateInput>
    /**
     * Choose, which order_table to update.
     */
    where: order_tableWhereUniqueInput
  }


  /**
   * order_table updateMany
   */
  export type order_tableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_tables.
     */
    data: XOR<order_tableUpdateManyMutationInput, order_tableUncheckedUpdateManyInput>
    /**
     * Filter which order_tables to update
     */
    where?: order_tableWhereInput
  }


  /**
   * order_table upsert
   */
  export type order_tableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * The filter to search for the order_table to update in case it exists.
     */
    where: order_tableWhereUniqueInput
    /**
     * In case the order_table found by the `where` argument doesn't exist, create a new order_table with this data.
     */
    create: XOR<order_tableCreateInput, order_tableUncheckedCreateInput>
    /**
     * In case the order_table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_tableUpdateInput, order_tableUncheckedUpdateInput>
  }


  /**
   * order_table delete
   */
  export type order_tableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    /**
     * Filter which order_table to delete.
     */
    where: order_tableWhereUniqueInput
  }


  /**
   * order_table deleteMany
   */
  export type order_tableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_tables to delete
     */
    where?: order_tableWhereInput
  }


  /**
   * order_table.company_order_table_FROMCOMPANY_IDTocompany
   */
  export type order_table$company_order_table_FROMCOMPANY_IDTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * order_table.company_order_table_TOCOMPANY_IDTocompany
   */
  export type order_table$company_order_table_TOCOMPANY_IDTocompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * order_table.orderitem
   */
  export type order_table$orderitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    where?: orderitemWhereInput
    orderBy?: orderitemOrderByWithRelationInput | orderitemOrderByWithRelationInput[]
    cursor?: orderitemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderitemScalarFieldEnum | OrderitemScalarFieldEnum[]
  }


  /**
   * order_table without action
   */
  export type order_tableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
  }



  /**
   * Model orderitem
   */

  export type AggregateOrderitem = {
    _count: OrderitemCountAggregateOutputType | null
    _avg: OrderitemAvgAggregateOutputType | null
    _sum: OrderitemSumAggregateOutputType | null
    _min: OrderitemMinAggregateOutputType | null
    _max: OrderitemMaxAggregateOutputType | null
  }

  export type OrderitemAvgAggregateOutputType = {
    ID: number | null
    ORDERID: number | null
    ORDERITEMID: number | null
    QUANTITY: number | null
    SYNCID: number | null
    TOTAL: Decimal | null
    UNITPRICE: Decimal | null
    FROMORDER_ID: number | null
    PRODUCT_ID: number | null
  }

  export type OrderitemSumAggregateOutputType = {
    ID: bigint | null
    ORDERID: number | null
    ORDERITEMID: number | null
    QUANTITY: number | null
    SYNCID: number | null
    TOTAL: Decimal | null
    UNITPRICE: Decimal | null
    FROMORDER_ID: bigint | null
    PRODUCT_ID: bigint | null
  }

  export type OrderitemMinAggregateOutputType = {
    ID: bigint | null
    INSTOCK: string | null
    NAME: string | null
    ORDERID: number | null
    ORDERITEMID: number | null
    QUANTITY: number | null
    SYNCID: number | null
    TOTAL: Decimal | null
    UNITOFMEASUREID: string | null
    UNITPRICE: Decimal | null
    FROMORDER_ID: bigint | null
    PRODUCT_ID: bigint | null
  }

  export type OrderitemMaxAggregateOutputType = {
    ID: bigint | null
    INSTOCK: string | null
    NAME: string | null
    ORDERID: number | null
    ORDERITEMID: number | null
    QUANTITY: number | null
    SYNCID: number | null
    TOTAL: Decimal | null
    UNITOFMEASUREID: string | null
    UNITPRICE: Decimal | null
    FROMORDER_ID: bigint | null
    PRODUCT_ID: bigint | null
  }

  export type OrderitemCountAggregateOutputType = {
    ID: number
    INSTOCK: number
    NAME: number
    ORDERID: number
    ORDERITEMID: number
    QUANTITY: number
    SYNCID: number
    TOTAL: number
    UNITOFMEASUREID: number
    UNITPRICE: number
    FROMORDER_ID: number
    PRODUCT_ID: number
    _all: number
  }


  export type OrderitemAvgAggregateInputType = {
    ID?: true
    ORDERID?: true
    ORDERITEMID?: true
    QUANTITY?: true
    SYNCID?: true
    TOTAL?: true
    UNITPRICE?: true
    FROMORDER_ID?: true
    PRODUCT_ID?: true
  }

  export type OrderitemSumAggregateInputType = {
    ID?: true
    ORDERID?: true
    ORDERITEMID?: true
    QUANTITY?: true
    SYNCID?: true
    TOTAL?: true
    UNITPRICE?: true
    FROMORDER_ID?: true
    PRODUCT_ID?: true
  }

  export type OrderitemMinAggregateInputType = {
    ID?: true
    INSTOCK?: true
    NAME?: true
    ORDERID?: true
    ORDERITEMID?: true
    QUANTITY?: true
    SYNCID?: true
    TOTAL?: true
    UNITOFMEASUREID?: true
    UNITPRICE?: true
    FROMORDER_ID?: true
    PRODUCT_ID?: true
  }

  export type OrderitemMaxAggregateInputType = {
    ID?: true
    INSTOCK?: true
    NAME?: true
    ORDERID?: true
    ORDERITEMID?: true
    QUANTITY?: true
    SYNCID?: true
    TOTAL?: true
    UNITOFMEASUREID?: true
    UNITPRICE?: true
    FROMORDER_ID?: true
    PRODUCT_ID?: true
  }

  export type OrderitemCountAggregateInputType = {
    ID?: true
    INSTOCK?: true
    NAME?: true
    ORDERID?: true
    ORDERITEMID?: true
    QUANTITY?: true
    SYNCID?: true
    TOTAL?: true
    UNITOFMEASUREID?: true
    UNITPRICE?: true
    FROMORDER_ID?: true
    PRODUCT_ID?: true
    _all?: true
  }

  export type OrderitemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderitem to aggregate.
     */
    where?: orderitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderitems to fetch.
     */
    orderBy?: orderitemOrderByWithRelationInput | orderitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderitems
    **/
    _count?: true | OrderitemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderitemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderitemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderitemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderitemMaxAggregateInputType
  }

  export type GetOrderitemAggregateType<T extends OrderitemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderitem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderitem[P]>
      : GetScalarType<T[P], AggregateOrderitem[P]>
  }




  export type orderitemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderitemWhereInput
    orderBy?: orderitemOrderByWithAggregationInput | orderitemOrderByWithAggregationInput[]
    by: OrderitemScalarFieldEnum[] | OrderitemScalarFieldEnum
    having?: orderitemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderitemCountAggregateInputType | true
    _avg?: OrderitemAvgAggregateInputType
    _sum?: OrderitemSumAggregateInputType
    _min?: OrderitemMinAggregateInputType
    _max?: OrderitemMaxAggregateInputType
  }

  export type OrderitemGroupByOutputType = {
    ID: bigint
    INSTOCK: string | null
    NAME: string | null
    ORDERID: number | null
    ORDERITEMID: number | null
    QUANTITY: number | null
    SYNCID: number | null
    TOTAL: Decimal | null
    UNITOFMEASUREID: string | null
    UNITPRICE: Decimal | null
    FROMORDER_ID: bigint | null
    PRODUCT_ID: bigint | null
    _count: OrderitemCountAggregateOutputType | null
    _avg: OrderitemAvgAggregateOutputType | null
    _sum: OrderitemSumAggregateOutputType | null
    _min: OrderitemMinAggregateOutputType | null
    _max: OrderitemMaxAggregateOutputType | null
  }

  type GetOrderitemGroupByPayload<T extends orderitemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderitemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderitemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderitemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderitemGroupByOutputType[P]>
        }
      >
    >


  export type orderitemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    INSTOCK?: boolean
    NAME?: boolean
    ORDERID?: boolean
    ORDERITEMID?: boolean
    QUANTITY?: boolean
    SYNCID?: boolean
    TOTAL?: boolean
    UNITOFMEASUREID?: boolean
    UNITPRICE?: boolean
    FROMORDER_ID?: boolean
    PRODUCT_ID?: boolean
    order_table?: boolean | orderitem$order_tableArgs<ExtArgs>
    product?: boolean | orderitem$productArgs<ExtArgs>
  }, ExtArgs["result"]["orderitem"]>

  export type orderitemSelectScalar = {
    ID?: boolean
    INSTOCK?: boolean
    NAME?: boolean
    ORDERID?: boolean
    ORDERITEMID?: boolean
    QUANTITY?: boolean
    SYNCID?: boolean
    TOTAL?: boolean
    UNITOFMEASUREID?: boolean
    UNITPRICE?: boolean
    FROMORDER_ID?: boolean
    PRODUCT_ID?: boolean
  }

  export type orderitemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_table?: boolean | orderitem$order_tableArgs<ExtArgs>
    product?: boolean | orderitem$productArgs<ExtArgs>
  }


  export type $orderitemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderitem"
    objects: {
      order_table: Prisma.$order_tablePayload<ExtArgs> | null
      product: Prisma.$productPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: bigint
      INSTOCK: string | null
      NAME: string | null
      ORDERID: number | null
      ORDERITEMID: number | null
      QUANTITY: number | null
      SYNCID: number | null
      TOTAL: Prisma.Decimal | null
      UNITOFMEASUREID: string | null
      UNITPRICE: Prisma.Decimal | null
      FROMORDER_ID: bigint | null
      PRODUCT_ID: bigint | null
    }, ExtArgs["result"]["orderitem"]>
    composites: {}
  }


  type orderitemGetPayload<S extends boolean | null | undefined | orderitemDefaultArgs> = $Result.GetResult<Prisma.$orderitemPayload, S>

  type orderitemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderitemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderitemCountAggregateInputType | true
    }

  export interface orderitemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderitem'], meta: { name: 'orderitem' } }
    /**
     * Find zero or one Orderitem that matches the filter.
     * @param {orderitemFindUniqueArgs} args - Arguments to find a Orderitem
     * @example
     * // Get one Orderitem
     * const orderitem = await prisma.orderitem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderitemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderitemFindUniqueArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Orderitem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {orderitemFindUniqueOrThrowArgs} args - Arguments to find a Orderitem
     * @example
     * // Get one Orderitem
     * const orderitem = await prisma.orderitem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderitemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderitemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Orderitem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderitemFindFirstArgs} args - Arguments to find a Orderitem
     * @example
     * // Get one Orderitem
     * const orderitem = await prisma.orderitem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderitemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderitemFindFirstArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Orderitem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderitemFindFirstOrThrowArgs} args - Arguments to find a Orderitem
     * @example
     * // Get one Orderitem
     * const orderitem = await prisma.orderitem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderitemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderitemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orderitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderitemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orderitems
     * const orderitems = await prisma.orderitem.findMany()
     * 
     * // Get first 10 Orderitems
     * const orderitems = await prisma.orderitem.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const orderitemWithIDOnly = await prisma.orderitem.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends orderitemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderitemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Orderitem.
     * @param {orderitemCreateArgs} args - Arguments to create a Orderitem.
     * @example
     * // Create one Orderitem
     * const Orderitem = await prisma.orderitem.create({
     *   data: {
     *     // ... data to create a Orderitem
     *   }
     * })
     * 
    **/
    create<T extends orderitemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderitemCreateArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orderitems.
     *     @param {orderitemCreateManyArgs} args - Arguments to create many Orderitems.
     *     @example
     *     // Create many Orderitems
     *     const orderitem = await prisma.orderitem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderitemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderitemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Orderitem.
     * @param {orderitemDeleteArgs} args - Arguments to delete one Orderitem.
     * @example
     * // Delete one Orderitem
     * const Orderitem = await prisma.orderitem.delete({
     *   where: {
     *     // ... filter to delete one Orderitem
     *   }
     * })
     * 
    **/
    delete<T extends orderitemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderitemDeleteArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Orderitem.
     * @param {orderitemUpdateArgs} args - Arguments to update one Orderitem.
     * @example
     * // Update one Orderitem
     * const orderitem = await prisma.orderitem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderitemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderitemUpdateArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orderitems.
     * @param {orderitemDeleteManyArgs} args - Arguments to filter Orderitems to delete.
     * @example
     * // Delete a few Orderitems
     * const { count } = await prisma.orderitem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderitemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderitemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orderitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderitemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orderitems
     * const orderitem = await prisma.orderitem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderitemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderitemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Orderitem.
     * @param {orderitemUpsertArgs} args - Arguments to update or create a Orderitem.
     * @example
     * // Update or create a Orderitem
     * const orderitem = await prisma.orderitem.upsert({
     *   create: {
     *     // ... data to create a Orderitem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orderitem we want to update
     *   }
     * })
    **/
    upsert<T extends orderitemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderitemUpsertArgs<ExtArgs>>
    ): Prisma__orderitemClient<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orderitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderitemCountArgs} args - Arguments to filter Orderitems to count.
     * @example
     * // Count the number of Orderitems
     * const count = await prisma.orderitem.count({
     *   where: {
     *     // ... the filter for the Orderitems we want to count
     *   }
     * })
    **/
    count<T extends orderitemCountArgs>(
      args?: Subset<T, orderitemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderitemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orderitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderitemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderitemAggregateArgs>(args: Subset<T, OrderitemAggregateArgs>): Prisma.PrismaPromise<GetOrderitemAggregateType<T>>

    /**
     * Group by Orderitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderitemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderitemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderitemGroupByArgs['orderBy'] }
        : { orderBy?: orderitemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderitemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderitemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderitem model
   */
  readonly fields: orderitemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderitem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderitemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    order_table<T extends orderitem$order_tableArgs<ExtArgs> = {}>(args?: Subset<T, orderitem$order_tableArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    product<T extends orderitem$productArgs<ExtArgs> = {}>(args?: Subset<T, orderitem$productArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the orderitem model
   */ 
  interface orderitemFieldRefs {
    readonly ID: FieldRef<"orderitem", 'BigInt'>
    readonly INSTOCK: FieldRef<"orderitem", 'String'>
    readonly NAME: FieldRef<"orderitem", 'String'>
    readonly ORDERID: FieldRef<"orderitem", 'Int'>
    readonly ORDERITEMID: FieldRef<"orderitem", 'Int'>
    readonly QUANTITY: FieldRef<"orderitem", 'Int'>
    readonly SYNCID: FieldRef<"orderitem", 'Int'>
    readonly TOTAL: FieldRef<"orderitem", 'Decimal'>
    readonly UNITOFMEASUREID: FieldRef<"orderitem", 'String'>
    readonly UNITPRICE: FieldRef<"orderitem", 'Decimal'>
    readonly FROMORDER_ID: FieldRef<"orderitem", 'BigInt'>
    readonly PRODUCT_ID: FieldRef<"orderitem", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * orderitem findUnique
   */
  export type orderitemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * Filter, which orderitem to fetch.
     */
    where: orderitemWhereUniqueInput
  }


  /**
   * orderitem findUniqueOrThrow
   */
  export type orderitemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * Filter, which orderitem to fetch.
     */
    where: orderitemWhereUniqueInput
  }


  /**
   * orderitem findFirst
   */
  export type orderitemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * Filter, which orderitem to fetch.
     */
    where?: orderitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderitems to fetch.
     */
    orderBy?: orderitemOrderByWithRelationInput | orderitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderitems.
     */
    cursor?: orderitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderitems.
     */
    distinct?: OrderitemScalarFieldEnum | OrderitemScalarFieldEnum[]
  }


  /**
   * orderitem findFirstOrThrow
   */
  export type orderitemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * Filter, which orderitem to fetch.
     */
    where?: orderitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderitems to fetch.
     */
    orderBy?: orderitemOrderByWithRelationInput | orderitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderitems.
     */
    cursor?: orderitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderitems.
     */
    distinct?: OrderitemScalarFieldEnum | OrderitemScalarFieldEnum[]
  }


  /**
   * orderitem findMany
   */
  export type orderitemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * Filter, which orderitems to fetch.
     */
    where?: orderitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderitems to fetch.
     */
    orderBy?: orderitemOrderByWithRelationInput | orderitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderitems.
     */
    cursor?: orderitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderitems.
     */
    skip?: number
    distinct?: OrderitemScalarFieldEnum | OrderitemScalarFieldEnum[]
  }


  /**
   * orderitem create
   */
  export type orderitemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * The data needed to create a orderitem.
     */
    data?: XOR<orderitemCreateInput, orderitemUncheckedCreateInput>
  }


  /**
   * orderitem createMany
   */
  export type orderitemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderitems.
     */
    data: orderitemCreateManyInput | orderitemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * orderitem update
   */
  export type orderitemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * The data needed to update a orderitem.
     */
    data: XOR<orderitemUpdateInput, orderitemUncheckedUpdateInput>
    /**
     * Choose, which orderitem to update.
     */
    where: orderitemWhereUniqueInput
  }


  /**
   * orderitem updateMany
   */
  export type orderitemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderitems.
     */
    data: XOR<orderitemUpdateManyMutationInput, orderitemUncheckedUpdateManyInput>
    /**
     * Filter which orderitems to update
     */
    where?: orderitemWhereInput
  }


  /**
   * orderitem upsert
   */
  export type orderitemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * The filter to search for the orderitem to update in case it exists.
     */
    where: orderitemWhereUniqueInput
    /**
     * In case the orderitem found by the `where` argument doesn't exist, create a new orderitem with this data.
     */
    create: XOR<orderitemCreateInput, orderitemUncheckedCreateInput>
    /**
     * In case the orderitem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderitemUpdateInput, orderitemUncheckedUpdateInput>
  }


  /**
   * orderitem delete
   */
  export type orderitemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    /**
     * Filter which orderitem to delete.
     */
    where: orderitemWhereUniqueInput
  }


  /**
   * orderitem deleteMany
   */
  export type orderitemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderitems to delete
     */
    where?: orderitemWhereInput
  }


  /**
   * orderitem.order_table
   */
  export type orderitem$order_tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_tableInclude<ExtArgs> | null
    where?: order_tableWhereInput
  }


  /**
   * orderitem.product
   */
  export type orderitem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
  }


  /**
   * orderitem without action
   */
  export type orderitemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
  }



  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    ID: number | null
    PRICE: number | null
    SYNCID: number | null
    FROMCOMPANY_ID: number | null
  }

  export type ProductSumAggregateOutputType = {
    ID: bigint | null
    PRICE: number | null
    SYNCID: number | null
    FROMCOMPANY_ID: bigint | null
  }

  export type ProductMinAggregateOutputType = {
    ID: bigint | null
    DESCRIPTION: string | null
    NAME: string | null
    PRICE: number | null
    PRODUCTAVAILABILITY: string | null
    PRODUCTCATEGORYID: string | null
    PRODUCTID: string | null
    PRODUCTUNITOFMEASUREID: string | null
    SYNCID: number | null
    FROMCOMPANY_ID: bigint | null
  }

  export type ProductMaxAggregateOutputType = {
    ID: bigint | null
    DESCRIPTION: string | null
    NAME: string | null
    PRICE: number | null
    PRODUCTAVAILABILITY: string | null
    PRODUCTCATEGORYID: string | null
    PRODUCTID: string | null
    PRODUCTUNITOFMEASUREID: string | null
    SYNCID: number | null
    FROMCOMPANY_ID: bigint | null
  }

  export type ProductCountAggregateOutputType = {
    ID: number
    DESCRIPTION: number
    NAME: number
    PRICE: number
    PRODUCTAVAILABILITY: number
    PRODUCTCATEGORYID: number
    PRODUCTID: number
    PRODUCTUNITOFMEASUREID: number
    SYNCID: number
    FROMCOMPANY_ID: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    ID?: true
    PRICE?: true
    SYNCID?: true
    FROMCOMPANY_ID?: true
  }

  export type ProductSumAggregateInputType = {
    ID?: true
    PRICE?: true
    SYNCID?: true
    FROMCOMPANY_ID?: true
  }

  export type ProductMinAggregateInputType = {
    ID?: true
    DESCRIPTION?: true
    NAME?: true
    PRICE?: true
    PRODUCTAVAILABILITY?: true
    PRODUCTCATEGORYID?: true
    PRODUCTID?: true
    PRODUCTUNITOFMEASUREID?: true
    SYNCID?: true
    FROMCOMPANY_ID?: true
  }

  export type ProductMaxAggregateInputType = {
    ID?: true
    DESCRIPTION?: true
    NAME?: true
    PRICE?: true
    PRODUCTAVAILABILITY?: true
    PRODUCTCATEGORYID?: true
    PRODUCTID?: true
    PRODUCTUNITOFMEASUREID?: true
    SYNCID?: true
    FROMCOMPANY_ID?: true
  }

  export type ProductCountAggregateInputType = {
    ID?: true
    DESCRIPTION?: true
    NAME?: true
    PRICE?: true
    PRODUCTAVAILABILITY?: true
    PRODUCTCATEGORYID?: true
    PRODUCTID?: true
    PRODUCTUNITOFMEASUREID?: true
    SYNCID?: true
    FROMCOMPANY_ID?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    ID: bigint
    DESCRIPTION: string | null
    NAME: string | null
    PRICE: number | null
    PRODUCTAVAILABILITY: string | null
    PRODUCTCATEGORYID: string | null
    PRODUCTID: string | null
    PRODUCTUNITOFMEASUREID: string | null
    SYNCID: number | null
    FROMCOMPANY_ID: bigint | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    DESCRIPTION?: boolean
    NAME?: boolean
    PRICE?: boolean
    PRODUCTAVAILABILITY?: boolean
    PRODUCTCATEGORYID?: boolean
    PRODUCTID?: boolean
    PRODUCTUNITOFMEASUREID?: boolean
    SYNCID?: boolean
    FROMCOMPANY_ID?: boolean
    orderitem?: boolean | product$orderitemArgs<ExtArgs>
    company?: boolean | product$companyArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    ID?: boolean
    DESCRIPTION?: boolean
    NAME?: boolean
    PRICE?: boolean
    PRODUCTAVAILABILITY?: boolean
    PRODUCTCATEGORYID?: boolean
    PRODUCTID?: boolean
    PRODUCTUNITOFMEASUREID?: boolean
    SYNCID?: boolean
    FROMCOMPANY_ID?: boolean
  }

  export type productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderitem?: boolean | product$orderitemArgs<ExtArgs>
    company?: boolean | product$companyArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {
      orderitem: Prisma.$orderitemPayload<ExtArgs>[]
      company: Prisma.$companyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: bigint
      DESCRIPTION: string | null
      NAME: string | null
      PRICE: number | null
      PRODUCTAVAILABILITY: string | null
      PRODUCTCATEGORYID: string | null
      PRODUCTID: string | null
      PRODUCTUNITOFMEASUREID: string | null
      SYNCID: number | null
      FROMCOMPANY_ID: bigint | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const productWithIDOnly = await prisma.product.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productCreateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productDeleteArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productUpsertArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    orderitem<T extends product$orderitemArgs<ExtArgs> = {}>(args?: Subset<T, product$orderitemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderitemPayload<ExtArgs>, T, 'findMany'> | Null>;

    company<T extends product$companyArgs<ExtArgs> = {}>(args?: Subset<T, product$companyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product model
   */ 
  interface productFieldRefs {
    readonly ID: FieldRef<"product", 'BigInt'>
    readonly DESCRIPTION: FieldRef<"product", 'String'>
    readonly NAME: FieldRef<"product", 'String'>
    readonly PRICE: FieldRef<"product", 'Int'>
    readonly PRODUCTAVAILABILITY: FieldRef<"product", 'String'>
    readonly PRODUCTCATEGORYID: FieldRef<"product", 'String'>
    readonly PRODUCTID: FieldRef<"product", 'String'>
    readonly PRODUCTUNITOFMEASUREID: FieldRef<"product", 'String'>
    readonly SYNCID: FieldRef<"product", 'Int'>
    readonly FROMCOMPANY_ID: FieldRef<"product", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data?: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }


  /**
   * product.orderitem
   */
  export type product$orderitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderitem
     */
    select?: orderitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderitemInclude<ExtArgs> | null
    where?: orderitemWhereInput
    orderBy?: orderitemOrderByWithRelationInput | orderitemOrderByWithRelationInput[]
    cursor?: orderitemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderitemScalarFieldEnum | OrderitemScalarFieldEnum[]
  }


  /**
   * product.company
   */
  export type product$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
  }



  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    ID: number | null
    COMPANYID: number | null
  }

  export type NotificationSumAggregateOutputType = {
    ID: bigint | null
    COMPANYID: bigint | null
  }

  export type NotificationMinAggregateOutputType = {
    ID: bigint | null
    DATE: Date | null
    NOTIFICATIONSTATUS: string | null
    NOTIFICATIONTYPE: string | null
    ORDERID: string | null
    TEXT: string | null
    COMPANYID: bigint | null
  }

  export type NotificationMaxAggregateOutputType = {
    ID: bigint | null
    DATE: Date | null
    NOTIFICATIONSTATUS: string | null
    NOTIFICATIONTYPE: string | null
    ORDERID: string | null
    TEXT: string | null
    COMPANYID: bigint | null
  }

  export type NotificationCountAggregateOutputType = {
    ID: number
    DATE: number
    NOTIFICATIONSTATUS: number
    NOTIFICATIONTYPE: number
    ORDERID: number
    TEXT: number
    COMPANYID: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    ID?: true
    COMPANYID?: true
  }

  export type NotificationSumAggregateInputType = {
    ID?: true
    COMPANYID?: true
  }

  export type NotificationMinAggregateInputType = {
    ID?: true
    DATE?: true
    NOTIFICATIONSTATUS?: true
    NOTIFICATIONTYPE?: true
    ORDERID?: true
    TEXT?: true
    COMPANYID?: true
  }

  export type NotificationMaxAggregateInputType = {
    ID?: true
    DATE?: true
    NOTIFICATIONSTATUS?: true
    NOTIFICATIONTYPE?: true
    ORDERID?: true
    TEXT?: true
    COMPANYID?: true
  }

  export type NotificationCountAggregateInputType = {
    ID?: true
    DATE?: true
    NOTIFICATIONSTATUS?: true
    NOTIFICATIONTYPE?: true
    ORDERID?: true
    TEXT?: true
    COMPANYID?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    ID: bigint
    DATE: Date | null
    NOTIFICATIONSTATUS: string | null
    NOTIFICATIONTYPE: string | null
    ORDERID: string | null
    TEXT: string | null
    COMPANYID: bigint | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    DATE?: boolean
    NOTIFICATIONSTATUS?: boolean
    NOTIFICATIONTYPE?: boolean
    ORDERID?: boolean
    TEXT?: boolean
    COMPANYID?: boolean
    company?: boolean | notification$companyArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectScalar = {
    ID?: boolean
    DATE?: boolean
    NOTIFICATIONSTATUS?: boolean
    NOTIFICATIONTYPE?: boolean
    ORDERID?: boolean
    TEXT?: boolean
    COMPANYID?: boolean
  }

  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | notification$companyArgs<ExtArgs>
  }


  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      company: Prisma.$companyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: bigint
      DATE: Date | null
      NOTIFICATIONSTATUS: string | null
      NOTIFICATIONTYPE: string | null
      ORDERID: string | null
      TEXT: string | null
      COMPANYID: bigint | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends notificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends notificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const notificationWithIDOnly = await prisma.notification.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends notificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends notificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, notificationCreateArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends notificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends notificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends notificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>
    ): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends notification$companyArgs<ExtArgs> = {}>(args?: Subset<T, notification$companyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the notification model
   */ 
  interface notificationFieldRefs {
    readonly ID: FieldRef<"notification", 'BigInt'>
    readonly DATE: FieldRef<"notification", 'DateTime'>
    readonly NOTIFICATIONSTATUS: FieldRef<"notification", 'String'>
    readonly NOTIFICATIONTYPE: FieldRef<"notification", 'String'>
    readonly ORDERID: FieldRef<"notification", 'String'>
    readonly TEXT: FieldRef<"notification", 'String'>
    readonly COMPANYID: FieldRef<"notification", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }


  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }


  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data?: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }


  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }


  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
  }


  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }


  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }


  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
  }


  /**
   * notification.company
   */
  export type notification$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    ID: 'ID',
    EMAIL: 'EMAIL',
    PASSWORD: 'PASSWORD',
    ROLE: 'ROLE',
    company_id: 'company_id'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    ID: 'ID',
    BANKACCOUNTNR: 'BANKACCOUNTNR',
    CUSTOMERSTART: 'CUSTOMERSTART',
    ISACTIVE: 'ISACTIVE',
    LOGO: 'LOGO',
    NAME: 'NAME',
    SECTOR: 'SECTOR',
    VATNUMBER: 'VATNUMBER',
    CITY: 'CITY',
    COUNTRY: 'COUNTRY',
    NUMBER: 'NUMBER',
    STREET: 'STREET',
    ZIPCODE: 'ZIPCODE',
    EMAIL: 'EMAIL',
    PHONENUMBER: 'PHONENUMBER'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const Company_known_companiesScalarFieldEnum: {
    company_id: 'company_id',
    known_company_id: 'known_company_id'
  };

  export type Company_known_companiesScalarFieldEnum = (typeof Company_known_companiesScalarFieldEnum)[keyof typeof Company_known_companiesScalarFieldEnum]


  export const Company_paymentoptionsScalarFieldEnum: {
    Company_ID: 'Company_ID',
    PAYMENTOPTIONS: 'PAYMENTOPTIONS'
  };

  export type Company_paymentoptionsScalarFieldEnum = (typeof Company_paymentoptionsScalarFieldEnum)[keyof typeof Company_paymentoptionsScalarFieldEnum]


  export const Company_update_requestsScalarFieldEnum: {
    ID: 'ID',
    NEWBANKACCOUNTNR: 'NEWBANKACCOUNTNR',
    NEWCUSTOMEREMAIL: 'NEWCUSTOMEREMAIL',
    NEWCUSTOMERPASSWORD: 'NEWCUSTOMERPASSWORD',
    NEWCUSTOMERSTART: 'NEWCUSTOMERSTART',
    NEWLOGO: 'NEWLOGO',
    NEWNAME: 'NEWNAME',
    NEWSECTOR: 'NEWSECTOR',
    NEWSUPPLIEREMAIL: 'NEWSUPPLIEREMAIL',
    NEWSUPPLIERPASSWORD: 'NEWSUPPLIERPASSWORD',
    NEWVATNUMBER: 'NEWVATNUMBER',
    OLDVATNUMBER: 'OLDVATNUMBER',
    REQUESTDATE: 'REQUESTDATE',
    CITY: 'CITY',
    COUNTRY: 'COUNTRY',
    NUMBER: 'NUMBER',
    STREET: 'STREET',
    ZIPCODE: 'ZIPCODE',
    EMAIL: 'EMAIL',
    PHONENUMBER: 'PHONENUMBER'
  };

  export type Company_update_requestsScalarFieldEnum = (typeof Company_update_requestsScalarFieldEnum)[keyof typeof Company_update_requestsScalarFieldEnum]


  export const Companyupdaterequest_newpaymentoptionsScalarFieldEnum: {
    CompanyUpdateRequest_ID: 'CompanyUpdateRequest_ID',
    NEWPAYMENTOPTIONS: 'NEWPAYMENTOPTIONS'
  };

  export type Companyupdaterequest_newpaymentoptionsScalarFieldEnum = (typeof Companyupdaterequest_newpaymentoptionsScalarFieldEnum)[keyof typeof Companyupdaterequest_newpaymentoptionsScalarFieldEnum]


  export const Order_tableScalarFieldEnum: {
    ID: 'ID',
    CURRENCY: 'CURRENCY',
    DATE: 'DATE',
    LASTPAYMENTREMINDER: 'LASTPAYMENTREMINDER',
    NAME: 'NAME',
    NETAMOUNT: 'NETAMOUNT',
    ORDERDATETIME: 'ORDERDATETIME',
    ORDERID: 'ORDERID',
    ORDERREFERENCE: 'ORDERREFERENCE',
    ORDERSTATUS: 'ORDERSTATUS',
    PAYMENTSTATUS: 'PAYMENTSTATUS',
    TAXAMOUNT: 'TAXAMOUNT',
    TOTALAMOUNT: 'TOTALAMOUNT',
    FROMCOMPANY_ID: 'FROMCOMPANY_ID',
    TOCOMPANY_ID: 'TOCOMPANY_ID'
  };

  export type Order_tableScalarFieldEnum = (typeof Order_tableScalarFieldEnum)[keyof typeof Order_tableScalarFieldEnum]


  export const OrderitemScalarFieldEnum: {
    ID: 'ID',
    INSTOCK: 'INSTOCK',
    NAME: 'NAME',
    ORDERID: 'ORDERID',
    ORDERITEMID: 'ORDERITEMID',
    QUANTITY: 'QUANTITY',
    SYNCID: 'SYNCID',
    TOTAL: 'TOTAL',
    UNITOFMEASUREID: 'UNITOFMEASUREID',
    UNITPRICE: 'UNITPRICE',
    FROMORDER_ID: 'FROMORDER_ID',
    PRODUCT_ID: 'PRODUCT_ID'
  };

  export type OrderitemScalarFieldEnum = (typeof OrderitemScalarFieldEnum)[keyof typeof OrderitemScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    ID: 'ID',
    DESCRIPTION: 'DESCRIPTION',
    NAME: 'NAME',
    PRICE: 'PRICE',
    PRODUCTAVAILABILITY: 'PRODUCTAVAILABILITY',
    PRODUCTCATEGORYID: 'PRODUCTCATEGORYID',
    PRODUCTID: 'PRODUCTID',
    PRODUCTUNITOFMEASUREID: 'PRODUCTUNITOFMEASUREID',
    SYNCID: 'SYNCID',
    FROMCOMPANY_ID: 'FROMCOMPANY_ID'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    ID: 'ID',
    DATE: 'DATE',
    NOTIFICATIONSTATUS: 'NOTIFICATIONSTATUS',
    NOTIFICATIONTYPE: 'NOTIFICATIONTYPE',
    ORDERID: 'ORDERID',
    TEXT: 'TEXT',
    COMPANYID: 'COMPANYID'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    
  /**
   * Deep Input Types
   */


  export type accountWhereInput = {
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    ID?: BigIntFilter<"account"> | bigint | number
    EMAIL?: StringNullableFilter<"account"> | string | null
    PASSWORD?: StringNullableFilter<"account"> | string | null
    ROLE?: IntNullableFilter<"account"> | number | null
    company_id?: BigIntNullableFilter<"account"> | bigint | number | null
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }

  export type accountOrderByWithRelationInput = {
    ID?: SortOrder
    EMAIL?: SortOrderInput | SortOrder
    PASSWORD?: SortOrderInput | SortOrder
    ROLE?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    company?: companyOrderByWithRelationInput
  }

  export type accountWhereUniqueInput = Prisma.AtLeast<{
    ID?: bigint | number
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    EMAIL?: StringNullableFilter<"account"> | string | null
    PASSWORD?: StringNullableFilter<"account"> | string | null
    ROLE?: IntNullableFilter<"account"> | number | null
    company_id?: BigIntNullableFilter<"account"> | bigint | number | null
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }, "ID">

  export type accountOrderByWithAggregationInput = {
    ID?: SortOrder
    EMAIL?: SortOrderInput | SortOrder
    PASSWORD?: SortOrderInput | SortOrder
    ROLE?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    _count?: accountCountOrderByAggregateInput
    _avg?: accountAvgOrderByAggregateInput
    _max?: accountMaxOrderByAggregateInput
    _min?: accountMinOrderByAggregateInput
    _sum?: accountSumOrderByAggregateInput
  }

  export type accountScalarWhereWithAggregatesInput = {
    AND?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    OR?: accountScalarWhereWithAggregatesInput[]
    NOT?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<"account"> | bigint | number
    EMAIL?: StringNullableWithAggregatesFilter<"account"> | string | null
    PASSWORD?: StringNullableWithAggregatesFilter<"account"> | string | null
    ROLE?: IntNullableWithAggregatesFilter<"account"> | number | null
    company_id?: BigIntNullableWithAggregatesFilter<"account"> | bigint | number | null
  }

  export type companyWhereInput = {
    AND?: companyWhereInput | companyWhereInput[]
    OR?: companyWhereInput[]
    NOT?: companyWhereInput | companyWhereInput[]
    ID?: BigIntFilter<"company"> | bigint | number
    BANKACCOUNTNR?: BigIntNullableFilter<"company"> | bigint | number | null
    CUSTOMERSTART?: DateTimeNullableFilter<"company"> | Date | string | null
    ISACTIVE?: BoolNullableFilter<"company"> | boolean | null
    LOGO?: StringNullableFilter<"company"> | string | null
    NAME?: StringNullableFilter<"company"> | string | null
    SECTOR?: StringNullableFilter<"company"> | string | null
    VATNUMBER?: StringNullableFilter<"company"> | string | null
    CITY?: StringNullableFilter<"company"> | string | null
    COUNTRY?: StringNullableFilter<"company"> | string | null
    NUMBER?: StringNullableFilter<"company"> | string | null
    STREET?: StringNullableFilter<"company"> | string | null
    ZIPCODE?: StringNullableFilter<"company"> | string | null
    EMAIL?: StringNullableFilter<"company"> | string | null
    PHONENUMBER?: StringNullableFilter<"company"> | string | null
    account?: AccountListRelationFilter
    company_known_companies_company_known_companies_company_idTocompany?: Company_known_companiesListRelationFilter
    company_known_companies_company_known_companies_known_company_idTocompany?: Company_known_companiesListRelationFilter
    notification?: NotificationListRelationFilter
    company_paymentoptions?: Company_paymentoptionsListRelationFilter
    order_table_order_table_FROMCOMPANY_IDTocompany?: Order_tableListRelationFilter
    order_table_order_table_TOCOMPANY_IDTocompany?: Order_tableListRelationFilter
    product?: ProductListRelationFilter
  }

  export type companyOrderByWithRelationInput = {
    ID?: SortOrder
    BANKACCOUNTNR?: SortOrderInput | SortOrder
    CUSTOMERSTART?: SortOrderInput | SortOrder
    ISACTIVE?: SortOrderInput | SortOrder
    LOGO?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    SECTOR?: SortOrderInput | SortOrder
    VATNUMBER?: SortOrderInput | SortOrder
    CITY?: SortOrderInput | SortOrder
    COUNTRY?: SortOrderInput | SortOrder
    NUMBER?: SortOrderInput | SortOrder
    STREET?: SortOrderInput | SortOrder
    ZIPCODE?: SortOrderInput | SortOrder
    EMAIL?: SortOrderInput | SortOrder
    PHONENUMBER?: SortOrderInput | SortOrder
    account?: accountOrderByRelationAggregateInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesOrderByRelationAggregateInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesOrderByRelationAggregateInput
    notification?: notificationOrderByRelationAggregateInput
    company_paymentoptions?: company_paymentoptionsOrderByRelationAggregateInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableOrderByRelationAggregateInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableOrderByRelationAggregateInput
    product?: productOrderByRelationAggregateInput
  }

  export type companyWhereUniqueInput = Prisma.AtLeast<{
    ID?: bigint | number
    AND?: companyWhereInput | companyWhereInput[]
    OR?: companyWhereInput[]
    NOT?: companyWhereInput | companyWhereInput[]
    BANKACCOUNTNR?: BigIntNullableFilter<"company"> | bigint | number | null
    CUSTOMERSTART?: DateTimeNullableFilter<"company"> | Date | string | null
    ISACTIVE?: BoolNullableFilter<"company"> | boolean | null
    LOGO?: StringNullableFilter<"company"> | string | null
    NAME?: StringNullableFilter<"company"> | string | null
    SECTOR?: StringNullableFilter<"company"> | string | null
    VATNUMBER?: StringNullableFilter<"company"> | string | null
    CITY?: StringNullableFilter<"company"> | string | null
    COUNTRY?: StringNullableFilter<"company"> | string | null
    NUMBER?: StringNullableFilter<"company"> | string | null
    STREET?: StringNullableFilter<"company"> | string | null
    ZIPCODE?: StringNullableFilter<"company"> | string | null
    EMAIL?: StringNullableFilter<"company"> | string | null
    PHONENUMBER?: StringNullableFilter<"company"> | string | null
    account?: AccountListRelationFilter
    company_known_companies_company_known_companies_company_idTocompany?: Company_known_companiesListRelationFilter
    company_known_companies_company_known_companies_known_company_idTocompany?: Company_known_companiesListRelationFilter
    notification?: NotificationListRelationFilter
    company_paymentoptions?: Company_paymentoptionsListRelationFilter
    order_table_order_table_FROMCOMPANY_IDTocompany?: Order_tableListRelationFilter
    order_table_order_table_TOCOMPANY_IDTocompany?: Order_tableListRelationFilter
    product?: ProductListRelationFilter
  }, "ID">

  export type companyOrderByWithAggregationInput = {
    ID?: SortOrder
    BANKACCOUNTNR?: SortOrderInput | SortOrder
    CUSTOMERSTART?: SortOrderInput | SortOrder
    ISACTIVE?: SortOrderInput | SortOrder
    LOGO?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    SECTOR?: SortOrderInput | SortOrder
    VATNUMBER?: SortOrderInput | SortOrder
    CITY?: SortOrderInput | SortOrder
    COUNTRY?: SortOrderInput | SortOrder
    NUMBER?: SortOrderInput | SortOrder
    STREET?: SortOrderInput | SortOrder
    ZIPCODE?: SortOrderInput | SortOrder
    EMAIL?: SortOrderInput | SortOrder
    PHONENUMBER?: SortOrderInput | SortOrder
    _count?: companyCountOrderByAggregateInput
    _avg?: companyAvgOrderByAggregateInput
    _max?: companyMaxOrderByAggregateInput
    _min?: companyMinOrderByAggregateInput
    _sum?: companySumOrderByAggregateInput
  }

  export type companyScalarWhereWithAggregatesInput = {
    AND?: companyScalarWhereWithAggregatesInput | companyScalarWhereWithAggregatesInput[]
    OR?: companyScalarWhereWithAggregatesInput[]
    NOT?: companyScalarWhereWithAggregatesInput | companyScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<"company"> | bigint | number
    BANKACCOUNTNR?: BigIntNullableWithAggregatesFilter<"company"> | bigint | number | null
    CUSTOMERSTART?: DateTimeNullableWithAggregatesFilter<"company"> | Date | string | null
    ISACTIVE?: BoolNullableWithAggregatesFilter<"company"> | boolean | null
    LOGO?: StringNullableWithAggregatesFilter<"company"> | string | null
    NAME?: StringNullableWithAggregatesFilter<"company"> | string | null
    SECTOR?: StringNullableWithAggregatesFilter<"company"> | string | null
    VATNUMBER?: StringNullableWithAggregatesFilter<"company"> | string | null
    CITY?: StringNullableWithAggregatesFilter<"company"> | string | null
    COUNTRY?: StringNullableWithAggregatesFilter<"company"> | string | null
    NUMBER?: StringNullableWithAggregatesFilter<"company"> | string | null
    STREET?: StringNullableWithAggregatesFilter<"company"> | string | null
    ZIPCODE?: StringNullableWithAggregatesFilter<"company"> | string | null
    EMAIL?: StringNullableWithAggregatesFilter<"company"> | string | null
    PHONENUMBER?: StringNullableWithAggregatesFilter<"company"> | string | null
  }

  export type company_known_companiesWhereInput = {
    AND?: company_known_companiesWhereInput | company_known_companiesWhereInput[]
    OR?: company_known_companiesWhereInput[]
    NOT?: company_known_companiesWhereInput | company_known_companiesWhereInput[]
    company_id?: BigIntFilter<"company_known_companies"> | bigint | number
    known_company_id?: BigIntFilter<"company_known_companies"> | bigint | number
    company_company_known_companies_company_idTocompany?: XOR<CompanyRelationFilter, companyWhereInput>
    company_company_known_companies_known_company_idTocompany?: XOR<CompanyRelationFilter, companyWhereInput>
  }

  export type company_known_companiesOrderByWithRelationInput = {
    company_id?: SortOrder
    known_company_id?: SortOrder
    company_company_known_companies_company_idTocompany?: companyOrderByWithRelationInput
    company_company_known_companies_known_company_idTocompany?: companyOrderByWithRelationInput
  }

  export type company_known_companiesWhereUniqueInput = Prisma.AtLeast<{
    company_id_known_company_id?: company_known_companiesCompany_idKnown_company_idCompoundUniqueInput
    AND?: company_known_companiesWhereInput | company_known_companiesWhereInput[]
    OR?: company_known_companiesWhereInput[]
    NOT?: company_known_companiesWhereInput | company_known_companiesWhereInput[]
    company_id?: BigIntFilter<"company_known_companies"> | bigint | number
    known_company_id?: BigIntFilter<"company_known_companies"> | bigint | number
    company_company_known_companies_company_idTocompany?: XOR<CompanyRelationFilter, companyWhereInput>
    company_company_known_companies_known_company_idTocompany?: XOR<CompanyRelationFilter, companyWhereInput>
  }, "company_id_known_company_id">

  export type company_known_companiesOrderByWithAggregationInput = {
    company_id?: SortOrder
    known_company_id?: SortOrder
    _count?: company_known_companiesCountOrderByAggregateInput
    _avg?: company_known_companiesAvgOrderByAggregateInput
    _max?: company_known_companiesMaxOrderByAggregateInput
    _min?: company_known_companiesMinOrderByAggregateInput
    _sum?: company_known_companiesSumOrderByAggregateInput
  }

  export type company_known_companiesScalarWhereWithAggregatesInput = {
    AND?: company_known_companiesScalarWhereWithAggregatesInput | company_known_companiesScalarWhereWithAggregatesInput[]
    OR?: company_known_companiesScalarWhereWithAggregatesInput[]
    NOT?: company_known_companiesScalarWhereWithAggregatesInput | company_known_companiesScalarWhereWithAggregatesInput[]
    company_id?: BigIntWithAggregatesFilter<"company_known_companies"> | bigint | number
    known_company_id?: BigIntWithAggregatesFilter<"company_known_companies"> | bigint | number
  }

  export type company_paymentoptionsWhereInput = {
    AND?: company_paymentoptionsWhereInput | company_paymentoptionsWhereInput[]
    OR?: company_paymentoptionsWhereInput[]
    NOT?: company_paymentoptionsWhereInput | company_paymentoptionsWhereInput[]
    Company_ID?: BigIntFilter<"company_paymentoptions"> | bigint | number
    PAYMENTOPTIONS?: StringFilter<"company_paymentoptions"> | string
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }

  export type company_paymentoptionsOrderByWithRelationInput = {
    Company_ID?: SortOrder
    PAYMENTOPTIONS?: SortOrder
    company?: companyOrderByWithRelationInput
  }

  export type company_paymentoptionsWhereUniqueInput = Prisma.AtLeast<{
    Company_ID_PAYMENTOPTIONS?: company_paymentoptionsCompany_IDPAYMENTOPTIONSCompoundUniqueInput
    AND?: company_paymentoptionsWhereInput | company_paymentoptionsWhereInput[]
    OR?: company_paymentoptionsWhereInput[]
    NOT?: company_paymentoptionsWhereInput | company_paymentoptionsWhereInput[]
    Company_ID?: BigIntFilter<"company_paymentoptions"> | bigint | number
    PAYMENTOPTIONS?: StringFilter<"company_paymentoptions"> | string
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }, "Company_ID_PAYMENTOPTIONS">

  export type company_paymentoptionsOrderByWithAggregationInput = {
    Company_ID?: SortOrder
    PAYMENTOPTIONS?: SortOrder
    _count?: company_paymentoptionsCountOrderByAggregateInput
    _avg?: company_paymentoptionsAvgOrderByAggregateInput
    _max?: company_paymentoptionsMaxOrderByAggregateInput
    _min?: company_paymentoptionsMinOrderByAggregateInput
    _sum?: company_paymentoptionsSumOrderByAggregateInput
  }

  export type company_paymentoptionsScalarWhereWithAggregatesInput = {
    AND?: company_paymentoptionsScalarWhereWithAggregatesInput | company_paymentoptionsScalarWhereWithAggregatesInput[]
    OR?: company_paymentoptionsScalarWhereWithAggregatesInput[]
    NOT?: company_paymentoptionsScalarWhereWithAggregatesInput | company_paymentoptionsScalarWhereWithAggregatesInput[]
    Company_ID?: BigIntWithAggregatesFilter<"company_paymentoptions"> | bigint | number
    PAYMENTOPTIONS?: StringWithAggregatesFilter<"company_paymentoptions"> | string
  }

  export type company_update_requestsWhereInput = {
    AND?: company_update_requestsWhereInput | company_update_requestsWhereInput[]
    OR?: company_update_requestsWhereInput[]
    NOT?: company_update_requestsWhereInput | company_update_requestsWhereInput[]
    ID?: BigIntFilter<"company_update_requests"> | bigint | number
    NEWBANKACCOUNTNR?: BigIntNullableFilter<"company_update_requests"> | bigint | number | null
    NEWCUSTOMEREMAIL?: StringNullableFilter<"company_update_requests"> | string | null
    NEWCUSTOMERPASSWORD?: StringNullableFilter<"company_update_requests"> | string | null
    NEWCUSTOMERSTART?: DateTimeNullableFilter<"company_update_requests"> | Date | string | null
    NEWLOGO?: StringNullableFilter<"company_update_requests"> | string | null
    NEWNAME?: StringNullableFilter<"company_update_requests"> | string | null
    NEWSECTOR?: StringNullableFilter<"company_update_requests"> | string | null
    NEWSUPPLIEREMAIL?: StringNullableFilter<"company_update_requests"> | string | null
    NEWSUPPLIERPASSWORD?: StringNullableFilter<"company_update_requests"> | string | null
    NEWVATNUMBER?: StringNullableFilter<"company_update_requests"> | string | null
    OLDVATNUMBER?: StringNullableFilter<"company_update_requests"> | string | null
    REQUESTDATE?: DateTimeNullableFilter<"company_update_requests"> | Date | string | null
    CITY?: StringNullableFilter<"company_update_requests"> | string | null
    COUNTRY?: StringNullableFilter<"company_update_requests"> | string | null
    NUMBER?: StringNullableFilter<"company_update_requests"> | string | null
    STREET?: StringNullableFilter<"company_update_requests"> | string | null
    ZIPCODE?: StringNullableFilter<"company_update_requests"> | string | null
    EMAIL?: StringNullableFilter<"company_update_requests"> | string | null
    PHONENUMBER?: StringNullableFilter<"company_update_requests"> | string | null
  }

  export type company_update_requestsOrderByWithRelationInput = {
    ID?: SortOrder
    NEWBANKACCOUNTNR?: SortOrderInput | SortOrder
    NEWCUSTOMEREMAIL?: SortOrderInput | SortOrder
    NEWCUSTOMERPASSWORD?: SortOrderInput | SortOrder
    NEWCUSTOMERSTART?: SortOrderInput | SortOrder
    NEWLOGO?: SortOrderInput | SortOrder
    NEWNAME?: SortOrderInput | SortOrder
    NEWSECTOR?: SortOrderInput | SortOrder
    NEWSUPPLIEREMAIL?: SortOrderInput | SortOrder
    NEWSUPPLIERPASSWORD?: SortOrderInput | SortOrder
    NEWVATNUMBER?: SortOrderInput | SortOrder
    OLDVATNUMBER?: SortOrderInput | SortOrder
    REQUESTDATE?: SortOrderInput | SortOrder
    CITY?: SortOrderInput | SortOrder
    COUNTRY?: SortOrderInput | SortOrder
    NUMBER?: SortOrderInput | SortOrder
    STREET?: SortOrderInput | SortOrder
    ZIPCODE?: SortOrderInput | SortOrder
    EMAIL?: SortOrderInput | SortOrder
    PHONENUMBER?: SortOrderInput | SortOrder
  }

  export type company_update_requestsWhereUniqueInput = Prisma.AtLeast<{
    ID?: bigint | number
    AND?: company_update_requestsWhereInput | company_update_requestsWhereInput[]
    OR?: company_update_requestsWhereInput[]
    NOT?: company_update_requestsWhereInput | company_update_requestsWhereInput[]
    NEWBANKACCOUNTNR?: BigIntNullableFilter<"company_update_requests"> | bigint | number | null
    NEWCUSTOMEREMAIL?: StringNullableFilter<"company_update_requests"> | string | null
    NEWCUSTOMERPASSWORD?: StringNullableFilter<"company_update_requests"> | string | null
    NEWCUSTOMERSTART?: DateTimeNullableFilter<"company_update_requests"> | Date | string | null
    NEWLOGO?: StringNullableFilter<"company_update_requests"> | string | null
    NEWNAME?: StringNullableFilter<"company_update_requests"> | string | null
    NEWSECTOR?: StringNullableFilter<"company_update_requests"> | string | null
    NEWSUPPLIEREMAIL?: StringNullableFilter<"company_update_requests"> | string | null
    NEWSUPPLIERPASSWORD?: StringNullableFilter<"company_update_requests"> | string | null
    NEWVATNUMBER?: StringNullableFilter<"company_update_requests"> | string | null
    OLDVATNUMBER?: StringNullableFilter<"company_update_requests"> | string | null
    REQUESTDATE?: DateTimeNullableFilter<"company_update_requests"> | Date | string | null
    CITY?: StringNullableFilter<"company_update_requests"> | string | null
    COUNTRY?: StringNullableFilter<"company_update_requests"> | string | null
    NUMBER?: StringNullableFilter<"company_update_requests"> | string | null
    STREET?: StringNullableFilter<"company_update_requests"> | string | null
    ZIPCODE?: StringNullableFilter<"company_update_requests"> | string | null
    EMAIL?: StringNullableFilter<"company_update_requests"> | string | null
    PHONENUMBER?: StringNullableFilter<"company_update_requests"> | string | null
  }, "ID">

  export type company_update_requestsOrderByWithAggregationInput = {
    ID?: SortOrder
    NEWBANKACCOUNTNR?: SortOrderInput | SortOrder
    NEWCUSTOMEREMAIL?: SortOrderInput | SortOrder
    NEWCUSTOMERPASSWORD?: SortOrderInput | SortOrder
    NEWCUSTOMERSTART?: SortOrderInput | SortOrder
    NEWLOGO?: SortOrderInput | SortOrder
    NEWNAME?: SortOrderInput | SortOrder
    NEWSECTOR?: SortOrderInput | SortOrder
    NEWSUPPLIEREMAIL?: SortOrderInput | SortOrder
    NEWSUPPLIERPASSWORD?: SortOrderInput | SortOrder
    NEWVATNUMBER?: SortOrderInput | SortOrder
    OLDVATNUMBER?: SortOrderInput | SortOrder
    REQUESTDATE?: SortOrderInput | SortOrder
    CITY?: SortOrderInput | SortOrder
    COUNTRY?: SortOrderInput | SortOrder
    NUMBER?: SortOrderInput | SortOrder
    STREET?: SortOrderInput | SortOrder
    ZIPCODE?: SortOrderInput | SortOrder
    EMAIL?: SortOrderInput | SortOrder
    PHONENUMBER?: SortOrderInput | SortOrder
    _count?: company_update_requestsCountOrderByAggregateInput
    _avg?: company_update_requestsAvgOrderByAggregateInput
    _max?: company_update_requestsMaxOrderByAggregateInput
    _min?: company_update_requestsMinOrderByAggregateInput
    _sum?: company_update_requestsSumOrderByAggregateInput
  }

  export type company_update_requestsScalarWhereWithAggregatesInput = {
    AND?: company_update_requestsScalarWhereWithAggregatesInput | company_update_requestsScalarWhereWithAggregatesInput[]
    OR?: company_update_requestsScalarWhereWithAggregatesInput[]
    NOT?: company_update_requestsScalarWhereWithAggregatesInput | company_update_requestsScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<"company_update_requests"> | bigint | number
    NEWBANKACCOUNTNR?: BigIntNullableWithAggregatesFilter<"company_update_requests"> | bigint | number | null
    NEWCUSTOMEREMAIL?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NEWCUSTOMERPASSWORD?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NEWCUSTOMERSTART?: DateTimeNullableWithAggregatesFilter<"company_update_requests"> | Date | string | null
    NEWLOGO?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NEWNAME?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NEWSECTOR?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NEWSUPPLIEREMAIL?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NEWSUPPLIERPASSWORD?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NEWVATNUMBER?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    OLDVATNUMBER?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    REQUESTDATE?: DateTimeNullableWithAggregatesFilter<"company_update_requests"> | Date | string | null
    CITY?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    COUNTRY?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    NUMBER?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    STREET?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    ZIPCODE?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    EMAIL?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
    PHONENUMBER?: StringNullableWithAggregatesFilter<"company_update_requests"> | string | null
  }

  export type companyupdaterequest_newpaymentoptionsWhereInput = {
    AND?: companyupdaterequest_newpaymentoptionsWhereInput | companyupdaterequest_newpaymentoptionsWhereInput[]
    OR?: companyupdaterequest_newpaymentoptionsWhereInput[]
    NOT?: companyupdaterequest_newpaymentoptionsWhereInput | companyupdaterequest_newpaymentoptionsWhereInput[]
    CompanyUpdateRequest_ID?: BigIntFilter<"companyupdaterequest_newpaymentoptions"> | bigint | number
    NEWPAYMENTOPTIONS?: StringFilter<"companyupdaterequest_newpaymentoptions"> | string
  }

  export type companyupdaterequest_newpaymentoptionsOrderByWithRelationInput = {
    CompanyUpdateRequest_ID?: SortOrder
    NEWPAYMENTOPTIONS?: SortOrder
  }

  export type companyupdaterequest_newpaymentoptionsWhereUniqueInput = Prisma.AtLeast<{
    CompanyUpdateRequest_ID_NEWPAYMENTOPTIONS?: companyupdaterequest_newpaymentoptionsCompanyUpdateRequest_IDNEWPAYMENTOPTIONSCompoundUniqueInput
    AND?: companyupdaterequest_newpaymentoptionsWhereInput | companyupdaterequest_newpaymentoptionsWhereInput[]
    OR?: companyupdaterequest_newpaymentoptionsWhereInput[]
    NOT?: companyupdaterequest_newpaymentoptionsWhereInput | companyupdaterequest_newpaymentoptionsWhereInput[]
    CompanyUpdateRequest_ID?: BigIntFilter<"companyupdaterequest_newpaymentoptions"> | bigint | number
    NEWPAYMENTOPTIONS?: StringFilter<"companyupdaterequest_newpaymentoptions"> | string
  }, "CompanyUpdateRequest_ID_NEWPAYMENTOPTIONS">

  export type companyupdaterequest_newpaymentoptionsOrderByWithAggregationInput = {
    CompanyUpdateRequest_ID?: SortOrder
    NEWPAYMENTOPTIONS?: SortOrder
    _count?: companyupdaterequest_newpaymentoptionsCountOrderByAggregateInput
    _avg?: companyupdaterequest_newpaymentoptionsAvgOrderByAggregateInput
    _max?: companyupdaterequest_newpaymentoptionsMaxOrderByAggregateInput
    _min?: companyupdaterequest_newpaymentoptionsMinOrderByAggregateInput
    _sum?: companyupdaterequest_newpaymentoptionsSumOrderByAggregateInput
  }

  export type companyupdaterequest_newpaymentoptionsScalarWhereWithAggregatesInput = {
    AND?: companyupdaterequest_newpaymentoptionsScalarWhereWithAggregatesInput | companyupdaterequest_newpaymentoptionsScalarWhereWithAggregatesInput[]
    OR?: companyupdaterequest_newpaymentoptionsScalarWhereWithAggregatesInput[]
    NOT?: companyupdaterequest_newpaymentoptionsScalarWhereWithAggregatesInput | companyupdaterequest_newpaymentoptionsScalarWhereWithAggregatesInput[]
    CompanyUpdateRequest_ID?: BigIntWithAggregatesFilter<"companyupdaterequest_newpaymentoptions"> | bigint | number
    NEWPAYMENTOPTIONS?: StringWithAggregatesFilter<"companyupdaterequest_newpaymentoptions"> | string
  }

  export type order_tableWhereInput = {
    AND?: order_tableWhereInput | order_tableWhereInput[]
    OR?: order_tableWhereInput[]
    NOT?: order_tableWhereInput | order_tableWhereInput[]
    ID?: BigIntFilter<"order_table"> | bigint | number
    CURRENCY?: StringNullableFilter<"order_table"> | string | null
    DATE?: StringNullableFilter<"order_table"> | string | null
    LASTPAYMENTREMINDER?: StringNullableFilter<"order_table"> | string | null
    NAME?: StringNullableFilter<"order_table"> | string | null
    NETAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    ORDERDATETIME?: DateTimeNullableFilter<"order_table"> | Date | string | null
    ORDERID?: StringNullableFilter<"order_table"> | string | null
    ORDERREFERENCE?: StringNullableFilter<"order_table"> | string | null
    ORDERSTATUS?: IntNullableFilter<"order_table"> | number | null
    PAYMENTSTATUS?: IntNullableFilter<"order_table"> | number | null
    TAXAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    TOTALAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    FROMCOMPANY_ID?: BigIntNullableFilter<"order_table"> | bigint | number | null
    TOCOMPANY_ID?: BigIntNullableFilter<"order_table"> | bigint | number | null
    company_order_table_FROMCOMPANY_IDTocompany?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    company_order_table_TOCOMPANY_IDTocompany?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    orderitem?: OrderitemListRelationFilter
  }

  export type order_tableOrderByWithRelationInput = {
    ID?: SortOrder
    CURRENCY?: SortOrderInput | SortOrder
    DATE?: SortOrderInput | SortOrder
    LASTPAYMENTREMINDER?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    NETAMOUNT?: SortOrderInput | SortOrder
    ORDERDATETIME?: SortOrderInput | SortOrder
    ORDERID?: SortOrderInput | SortOrder
    ORDERREFERENCE?: SortOrderInput | SortOrder
    ORDERSTATUS?: SortOrderInput | SortOrder
    PAYMENTSTATUS?: SortOrderInput | SortOrder
    TAXAMOUNT?: SortOrderInput | SortOrder
    TOTALAMOUNT?: SortOrderInput | SortOrder
    FROMCOMPANY_ID?: SortOrderInput | SortOrder
    TOCOMPANY_ID?: SortOrderInput | SortOrder
    company_order_table_FROMCOMPANY_IDTocompany?: companyOrderByWithRelationInput
    company_order_table_TOCOMPANY_IDTocompany?: companyOrderByWithRelationInput
    orderitem?: orderitemOrderByRelationAggregateInput
  }

  export type order_tableWhereUniqueInput = Prisma.AtLeast<{
    ID?: bigint | number
    ORDERID?: string
    AND?: order_tableWhereInput | order_tableWhereInput[]
    OR?: order_tableWhereInput[]
    NOT?: order_tableWhereInput | order_tableWhereInput[]
    CURRENCY?: StringNullableFilter<"order_table"> | string | null
    DATE?: StringNullableFilter<"order_table"> | string | null
    LASTPAYMENTREMINDER?: StringNullableFilter<"order_table"> | string | null
    NAME?: StringNullableFilter<"order_table"> | string | null
    NETAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    ORDERDATETIME?: DateTimeNullableFilter<"order_table"> | Date | string | null
    ORDERREFERENCE?: StringNullableFilter<"order_table"> | string | null
    ORDERSTATUS?: IntNullableFilter<"order_table"> | number | null
    PAYMENTSTATUS?: IntNullableFilter<"order_table"> | number | null
    TAXAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    TOTALAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    FROMCOMPANY_ID?: BigIntNullableFilter<"order_table"> | bigint | number | null
    TOCOMPANY_ID?: BigIntNullableFilter<"order_table"> | bigint | number | null
    company_order_table_FROMCOMPANY_IDTocompany?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    company_order_table_TOCOMPANY_IDTocompany?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    orderitem?: OrderitemListRelationFilter
  }, "ID" | "ORDERID">

  export type order_tableOrderByWithAggregationInput = {
    ID?: SortOrder
    CURRENCY?: SortOrderInput | SortOrder
    DATE?: SortOrderInput | SortOrder
    LASTPAYMENTREMINDER?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    NETAMOUNT?: SortOrderInput | SortOrder
    ORDERDATETIME?: SortOrderInput | SortOrder
    ORDERID?: SortOrderInput | SortOrder
    ORDERREFERENCE?: SortOrderInput | SortOrder
    ORDERSTATUS?: SortOrderInput | SortOrder
    PAYMENTSTATUS?: SortOrderInput | SortOrder
    TAXAMOUNT?: SortOrderInput | SortOrder
    TOTALAMOUNT?: SortOrderInput | SortOrder
    FROMCOMPANY_ID?: SortOrderInput | SortOrder
    TOCOMPANY_ID?: SortOrderInput | SortOrder
    _count?: order_tableCountOrderByAggregateInput
    _avg?: order_tableAvgOrderByAggregateInput
    _max?: order_tableMaxOrderByAggregateInput
    _min?: order_tableMinOrderByAggregateInput
    _sum?: order_tableSumOrderByAggregateInput
  }

  export type order_tableScalarWhereWithAggregatesInput = {
    AND?: order_tableScalarWhereWithAggregatesInput | order_tableScalarWhereWithAggregatesInput[]
    OR?: order_tableScalarWhereWithAggregatesInput[]
    NOT?: order_tableScalarWhereWithAggregatesInput | order_tableScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<"order_table"> | bigint | number
    CURRENCY?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    DATE?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    LASTPAYMENTREMINDER?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    NAME?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    NETAMOUNT?: FloatNullableWithAggregatesFilter<"order_table"> | number | null
    ORDERDATETIME?: DateTimeNullableWithAggregatesFilter<"order_table"> | Date | string | null
    ORDERID?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    ORDERREFERENCE?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    ORDERSTATUS?: IntNullableWithAggregatesFilter<"order_table"> | number | null
    PAYMENTSTATUS?: IntNullableWithAggregatesFilter<"order_table"> | number | null
    TAXAMOUNT?: FloatNullableWithAggregatesFilter<"order_table"> | number | null
    TOTALAMOUNT?: FloatNullableWithAggregatesFilter<"order_table"> | number | null
    FROMCOMPANY_ID?: BigIntNullableWithAggregatesFilter<"order_table"> | bigint | number | null
    TOCOMPANY_ID?: BigIntNullableWithAggregatesFilter<"order_table"> | bigint | number | null
  }

  export type orderitemWhereInput = {
    AND?: orderitemWhereInput | orderitemWhereInput[]
    OR?: orderitemWhereInput[]
    NOT?: orderitemWhereInput | orderitemWhereInput[]
    ID?: BigIntFilter<"orderitem"> | bigint | number
    INSTOCK?: StringNullableFilter<"orderitem"> | string | null
    NAME?: StringNullableFilter<"orderitem"> | string | null
    ORDERID?: IntNullableFilter<"orderitem"> | number | null
    ORDERITEMID?: IntNullableFilter<"orderitem"> | number | null
    QUANTITY?: IntNullableFilter<"orderitem"> | number | null
    SYNCID?: IntNullableFilter<"orderitem"> | number | null
    TOTAL?: DecimalNullableFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: StringNullableFilter<"orderitem"> | string | null
    UNITPRICE?: DecimalNullableFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: BigIntNullableFilter<"orderitem"> | bigint | number | null
    PRODUCT_ID?: BigIntNullableFilter<"orderitem"> | bigint | number | null
    order_table?: XOR<Order_tableNullableRelationFilter, order_tableWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, productWhereInput> | null
  }

  export type orderitemOrderByWithRelationInput = {
    ID?: SortOrder
    INSTOCK?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    ORDERID?: SortOrderInput | SortOrder
    ORDERITEMID?: SortOrderInput | SortOrder
    QUANTITY?: SortOrderInput | SortOrder
    SYNCID?: SortOrderInput | SortOrder
    TOTAL?: SortOrderInput | SortOrder
    UNITOFMEASUREID?: SortOrderInput | SortOrder
    UNITPRICE?: SortOrderInput | SortOrder
    FROMORDER_ID?: SortOrderInput | SortOrder
    PRODUCT_ID?: SortOrderInput | SortOrder
    order_table?: order_tableOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type orderitemWhereUniqueInput = Prisma.AtLeast<{
    ID?: bigint | number
    AND?: orderitemWhereInput | orderitemWhereInput[]
    OR?: orderitemWhereInput[]
    NOT?: orderitemWhereInput | orderitemWhereInput[]
    INSTOCK?: StringNullableFilter<"orderitem"> | string | null
    NAME?: StringNullableFilter<"orderitem"> | string | null
    ORDERID?: IntNullableFilter<"orderitem"> | number | null
    ORDERITEMID?: IntNullableFilter<"orderitem"> | number | null
    QUANTITY?: IntNullableFilter<"orderitem"> | number | null
    SYNCID?: IntNullableFilter<"orderitem"> | number | null
    TOTAL?: DecimalNullableFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: StringNullableFilter<"orderitem"> | string | null
    UNITPRICE?: DecimalNullableFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: BigIntNullableFilter<"orderitem"> | bigint | number | null
    PRODUCT_ID?: BigIntNullableFilter<"orderitem"> | bigint | number | null
    order_table?: XOR<Order_tableNullableRelationFilter, order_tableWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, productWhereInput> | null
  }, "ID">

  export type orderitemOrderByWithAggregationInput = {
    ID?: SortOrder
    INSTOCK?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    ORDERID?: SortOrderInput | SortOrder
    ORDERITEMID?: SortOrderInput | SortOrder
    QUANTITY?: SortOrderInput | SortOrder
    SYNCID?: SortOrderInput | SortOrder
    TOTAL?: SortOrderInput | SortOrder
    UNITOFMEASUREID?: SortOrderInput | SortOrder
    UNITPRICE?: SortOrderInput | SortOrder
    FROMORDER_ID?: SortOrderInput | SortOrder
    PRODUCT_ID?: SortOrderInput | SortOrder
    _count?: orderitemCountOrderByAggregateInput
    _avg?: orderitemAvgOrderByAggregateInput
    _max?: orderitemMaxOrderByAggregateInput
    _min?: orderitemMinOrderByAggregateInput
    _sum?: orderitemSumOrderByAggregateInput
  }

  export type orderitemScalarWhereWithAggregatesInput = {
    AND?: orderitemScalarWhereWithAggregatesInput | orderitemScalarWhereWithAggregatesInput[]
    OR?: orderitemScalarWhereWithAggregatesInput[]
    NOT?: orderitemScalarWhereWithAggregatesInput | orderitemScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<"orderitem"> | bigint | number
    INSTOCK?: StringNullableWithAggregatesFilter<"orderitem"> | string | null
    NAME?: StringNullableWithAggregatesFilter<"orderitem"> | string | null
    ORDERID?: IntNullableWithAggregatesFilter<"orderitem"> | number | null
    ORDERITEMID?: IntNullableWithAggregatesFilter<"orderitem"> | number | null
    QUANTITY?: IntNullableWithAggregatesFilter<"orderitem"> | number | null
    SYNCID?: IntNullableWithAggregatesFilter<"orderitem"> | number | null
    TOTAL?: DecimalNullableWithAggregatesFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: StringNullableWithAggregatesFilter<"orderitem"> | string | null
    UNITPRICE?: DecimalNullableWithAggregatesFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: BigIntNullableWithAggregatesFilter<"orderitem"> | bigint | number | null
    PRODUCT_ID?: BigIntNullableWithAggregatesFilter<"orderitem"> | bigint | number | null
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    ID?: BigIntFilter<"product"> | bigint | number
    DESCRIPTION?: StringNullableFilter<"product"> | string | null
    NAME?: StringNullableFilter<"product"> | string | null
    PRICE?: IntNullableFilter<"product"> | number | null
    PRODUCTAVAILABILITY?: StringNullableFilter<"product"> | string | null
    PRODUCTCATEGORYID?: StringNullableFilter<"product"> | string | null
    PRODUCTID?: StringNullableFilter<"product"> | string | null
    PRODUCTUNITOFMEASUREID?: StringNullableFilter<"product"> | string | null
    SYNCID?: IntNullableFilter<"product"> | number | null
    FROMCOMPANY_ID?: BigIntNullableFilter<"product"> | bigint | number | null
    orderitem?: OrderitemListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }

  export type productOrderByWithRelationInput = {
    ID?: SortOrder
    DESCRIPTION?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    PRICE?: SortOrderInput | SortOrder
    PRODUCTAVAILABILITY?: SortOrderInput | SortOrder
    PRODUCTCATEGORYID?: SortOrderInput | SortOrder
    PRODUCTID?: SortOrderInput | SortOrder
    PRODUCTUNITOFMEASUREID?: SortOrderInput | SortOrder
    SYNCID?: SortOrderInput | SortOrder
    FROMCOMPANY_ID?: SortOrderInput | SortOrder
    orderitem?: orderitemOrderByRelationAggregateInput
    company?: companyOrderByWithRelationInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    ID?: bigint | number
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    DESCRIPTION?: StringNullableFilter<"product"> | string | null
    NAME?: StringNullableFilter<"product"> | string | null
    PRICE?: IntNullableFilter<"product"> | number | null
    PRODUCTAVAILABILITY?: StringNullableFilter<"product"> | string | null
    PRODUCTCATEGORYID?: StringNullableFilter<"product"> | string | null
    PRODUCTID?: StringNullableFilter<"product"> | string | null
    PRODUCTUNITOFMEASUREID?: StringNullableFilter<"product"> | string | null
    SYNCID?: IntNullableFilter<"product"> | number | null
    FROMCOMPANY_ID?: BigIntNullableFilter<"product"> | bigint | number | null
    orderitem?: OrderitemListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }, "ID">

  export type productOrderByWithAggregationInput = {
    ID?: SortOrder
    DESCRIPTION?: SortOrderInput | SortOrder
    NAME?: SortOrderInput | SortOrder
    PRICE?: SortOrderInput | SortOrder
    PRODUCTAVAILABILITY?: SortOrderInput | SortOrder
    PRODUCTCATEGORYID?: SortOrderInput | SortOrder
    PRODUCTID?: SortOrderInput | SortOrder
    PRODUCTUNITOFMEASUREID?: SortOrderInput | SortOrder
    SYNCID?: SortOrderInput | SortOrder
    FROMCOMPANY_ID?: SortOrderInput | SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<"product"> | bigint | number
    DESCRIPTION?: StringNullableWithAggregatesFilter<"product"> | string | null
    NAME?: StringNullableWithAggregatesFilter<"product"> | string | null
    PRICE?: IntNullableWithAggregatesFilter<"product"> | number | null
    PRODUCTAVAILABILITY?: StringNullableWithAggregatesFilter<"product"> | string | null
    PRODUCTCATEGORYID?: StringNullableWithAggregatesFilter<"product"> | string | null
    PRODUCTID?: StringNullableWithAggregatesFilter<"product"> | string | null
    PRODUCTUNITOFMEASUREID?: StringNullableWithAggregatesFilter<"product"> | string | null
    SYNCID?: IntNullableWithAggregatesFilter<"product"> | number | null
    FROMCOMPANY_ID?: BigIntNullableWithAggregatesFilter<"product"> | bigint | number | null
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    ID?: BigIntFilter<"notification"> | bigint | number
    DATE?: DateTimeNullableFilter<"notification"> | Date | string | null
    NOTIFICATIONSTATUS?: StringNullableFilter<"notification"> | string | null
    NOTIFICATIONTYPE?: StringNullableFilter<"notification"> | string | null
    ORDERID?: StringNullableFilter<"notification"> | string | null
    TEXT?: StringNullableFilter<"notification"> | string | null
    COMPANYID?: BigIntNullableFilter<"notification"> | bigint | number | null
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }

  export type notificationOrderByWithRelationInput = {
    ID?: SortOrder
    DATE?: SortOrderInput | SortOrder
    NOTIFICATIONSTATUS?: SortOrderInput | SortOrder
    NOTIFICATIONTYPE?: SortOrderInput | SortOrder
    ORDERID?: SortOrderInput | SortOrder
    TEXT?: SortOrderInput | SortOrder
    COMPANYID?: SortOrderInput | SortOrder
    company?: companyOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    ID?: bigint | number
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    DATE?: DateTimeNullableFilter<"notification"> | Date | string | null
    NOTIFICATIONSTATUS?: StringNullableFilter<"notification"> | string | null
    NOTIFICATIONTYPE?: StringNullableFilter<"notification"> | string | null
    ORDERID?: StringNullableFilter<"notification"> | string | null
    TEXT?: StringNullableFilter<"notification"> | string | null
    COMPANYID?: BigIntNullableFilter<"notification"> | bigint | number | null
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
  }, "ID">

  export type notificationOrderByWithAggregationInput = {
    ID?: SortOrder
    DATE?: SortOrderInput | SortOrder
    NOTIFICATIONSTATUS?: SortOrderInput | SortOrder
    NOTIFICATIONTYPE?: SortOrderInput | SortOrder
    ORDERID?: SortOrderInput | SortOrder
    TEXT?: SortOrderInput | SortOrder
    COMPANYID?: SortOrderInput | SortOrder
    _count?: notificationCountOrderByAggregateInput
    _avg?: notificationAvgOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
    _sum?: notificationSumOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<"notification"> | bigint | number
    DATE?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
    NOTIFICATIONSTATUS?: StringNullableWithAggregatesFilter<"notification"> | string | null
    NOTIFICATIONTYPE?: StringNullableWithAggregatesFilter<"notification"> | string | null
    ORDERID?: StringNullableWithAggregatesFilter<"notification"> | string | null
    TEXT?: StringNullableWithAggregatesFilter<"notification"> | string | null
    COMPANYID?: BigIntNullableWithAggregatesFilter<"notification"> | bigint | number | null
  }

  export type accountCreateInput = {
    ID?: bigint | number
    EMAIL?: string | null
    PASSWORD?: string | null
    ROLE?: number | null
    company?: companyCreateNestedOneWithoutAccountInput
  }

  export type accountUncheckedCreateInput = {
    ID?: bigint | number
    EMAIL?: string | null
    PASSWORD?: string | null
    ROLE?: number | null
    company_id?: bigint | number | null
  }

  export type accountUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    ROLE?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companyUpdateOneWithoutAccountNestedInput
  }

  export type accountUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    ROLE?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type accountCreateManyInput = {
    ID?: bigint | number
    EMAIL?: string | null
    PASSWORD?: string | null
    ROLE?: number | null
    company_id?: bigint | number | null
  }

  export type accountUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    ROLE?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accountUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    ROLE?: NullableIntFieldUpdateOperationsInput | number | null
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type companyCreateInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyCreateManyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
  }

  export type companyUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companyUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_known_companiesCreateInput = {
    company_company_known_companies_company_idTocompany: companyCreateNestedOneWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput
    company_company_known_companies_known_company_idTocompany: companyCreateNestedOneWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput
  }

  export type company_known_companiesUncheckedCreateInput = {
    company_id: bigint | number
    known_company_id: bigint | number
  }

  export type company_known_companiesUpdateInput = {
    company_company_known_companies_company_idTocompany?: companyUpdateOneRequiredWithoutCompany_known_companies_company_known_companies_company_idTocompanyNestedInput
    company_company_known_companies_known_company_idTocompany?: companyUpdateOneRequiredWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyNestedInput
  }

  export type company_known_companiesUncheckedUpdateInput = {
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    known_company_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type company_known_companiesCreateManyInput = {
    company_id: bigint | number
    known_company_id: bigint | number
  }

  export type company_known_companiesUpdateManyMutationInput = {

  }

  export type company_known_companiesUncheckedUpdateManyInput = {
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    known_company_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type company_paymentoptionsCreateInput = {
    PAYMENTOPTIONS: string
    company?: companyCreateNestedOneWithoutCompany_paymentoptionsInput
  }

  export type company_paymentoptionsUncheckedCreateInput = {
    Company_ID: bigint | number
    PAYMENTOPTIONS: string
  }

  export type company_paymentoptionsUpdateInput = {
    PAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateOneWithoutCompany_paymentoptionsNestedInput
  }

  export type company_paymentoptionsUncheckedUpdateInput = {
    Company_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type company_paymentoptionsCreateManyInput = {
    Company_ID: bigint | number
    PAYMENTOPTIONS: string
  }

  export type company_paymentoptionsUpdateManyMutationInput = {
    PAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type company_paymentoptionsUncheckedUpdateManyInput = {
    Company_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type company_update_requestsCreateInput = {
    ID?: bigint | number
    NEWBANKACCOUNTNR?: bigint | number | null
    NEWCUSTOMEREMAIL?: string | null
    NEWCUSTOMERPASSWORD?: string | null
    NEWCUSTOMERSTART?: Date | string | null
    NEWLOGO?: string | null
    NEWNAME?: string | null
    NEWSECTOR?: string | null
    NEWSUPPLIEREMAIL?: string | null
    NEWSUPPLIERPASSWORD?: string | null
    NEWVATNUMBER?: string | null
    OLDVATNUMBER?: string | null
    REQUESTDATE?: Date | string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
  }

  export type company_update_requestsUncheckedCreateInput = {
    ID?: bigint | number
    NEWBANKACCOUNTNR?: bigint | number | null
    NEWCUSTOMEREMAIL?: string | null
    NEWCUSTOMERPASSWORD?: string | null
    NEWCUSTOMERSTART?: Date | string | null
    NEWLOGO?: string | null
    NEWNAME?: string | null
    NEWSECTOR?: string | null
    NEWSUPPLIEREMAIL?: string | null
    NEWSUPPLIERPASSWORD?: string | null
    NEWVATNUMBER?: string | null
    OLDVATNUMBER?: string | null
    REQUESTDATE?: Date | string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
  }

  export type company_update_requestsUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    NEWBANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    NEWCUSTOMEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NEWLOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NEWNAME?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    OLDVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTDATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_update_requestsUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    NEWBANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    NEWCUSTOMEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NEWLOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NEWNAME?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    OLDVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTDATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_update_requestsCreateManyInput = {
    ID?: bigint | number
    NEWBANKACCOUNTNR?: bigint | number | null
    NEWCUSTOMEREMAIL?: string | null
    NEWCUSTOMERPASSWORD?: string | null
    NEWCUSTOMERSTART?: Date | string | null
    NEWLOGO?: string | null
    NEWNAME?: string | null
    NEWSECTOR?: string | null
    NEWSUPPLIEREMAIL?: string | null
    NEWSUPPLIERPASSWORD?: string | null
    NEWVATNUMBER?: string | null
    OLDVATNUMBER?: string | null
    REQUESTDATE?: Date | string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
  }

  export type company_update_requestsUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    NEWBANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    NEWCUSTOMEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NEWLOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NEWNAME?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    OLDVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTDATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_update_requestsUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    NEWBANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    NEWCUSTOMEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWCUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NEWLOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NEWNAME?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIEREMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    NEWSUPPLIERPASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    NEWVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    OLDVATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTDATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companyupdaterequest_newpaymentoptionsCreateInput = {
    NEWPAYMENTOPTIONS: string
  }

  export type companyupdaterequest_newpaymentoptionsUncheckedCreateInput = {
    CompanyUpdateRequest_ID: bigint | number
    NEWPAYMENTOPTIONS: string
  }

  export type companyupdaterequest_newpaymentoptionsUpdateInput = {
    NEWPAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type companyupdaterequest_newpaymentoptionsUncheckedUpdateInput = {
    CompanyUpdateRequest_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    NEWPAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type companyupdaterequest_newpaymentoptionsCreateManyInput = {
    CompanyUpdateRequest_ID: bigint | number
    NEWPAYMENTOPTIONS: string
  }

  export type companyupdaterequest_newpaymentoptionsUpdateManyMutationInput = {
    NEWPAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type companyupdaterequest_newpaymentoptionsUncheckedUpdateManyInput = {
    CompanyUpdateRequest_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    NEWPAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type order_tableCreateInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    company_order_table_FROMCOMPANY_IDTocompany?: companyCreateNestedOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput
    company_order_table_TOCOMPANY_IDTocompany?: companyCreateNestedOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput
    orderitem?: orderitemCreateNestedManyWithoutOrder_tableInput
  }

  export type order_tableUncheckedCreateInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    FROMCOMPANY_ID?: bigint | number | null
    TOCOMPANY_ID?: bigint | number | null
    orderitem?: orderitemUncheckedCreateNestedManyWithoutOrder_tableInput
  }

  export type order_tableUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    company_order_table_FROMCOMPANY_IDTocompany?: companyUpdateOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyNestedInput
    company_order_table_TOCOMPANY_IDTocompany?: companyUpdateOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyNestedInput
    orderitem?: orderitemUpdateManyWithoutOrder_tableNestedInput
  }

  export type order_tableUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    TOCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderitem?: orderitemUncheckedUpdateManyWithoutOrder_tableNestedInput
  }

  export type order_tableCreateManyInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    FROMCOMPANY_ID?: bigint | number | null
    TOCOMPANY_ID?: bigint | number | null
  }

  export type order_tableUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type order_tableUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    TOCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type orderitemCreateInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    order_table?: order_tableCreateNestedOneWithoutOrderitemInput
    product?: productCreateNestedOneWithoutOrderitemInput
  }

  export type orderitemUncheckedCreateInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: bigint | number | null
    PRODUCT_ID?: bigint | number | null
  }

  export type orderitemUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_table?: order_tableUpdateOneWithoutOrderitemNestedInput
    product?: productUpdateOneWithoutOrderitemNestedInput
  }

  export type orderitemUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRODUCT_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type orderitemCreateManyInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: bigint | number | null
    PRODUCT_ID?: bigint | number | null
  }

  export type orderitemUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type orderitemUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRODUCT_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type productCreateInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
    orderitem?: orderitemCreateNestedManyWithoutProductInput
    company?: companyCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
    FROMCOMPANY_ID?: bigint | number | null
    orderitem?: orderitemUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    orderitem?: orderitemUpdateManyWithoutProductNestedInput
    company?: companyUpdateOneWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderitem?: orderitemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
    FROMCOMPANY_ID?: bigint | number | null
  }

  export type productUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type notificationCreateInput = {
    ID?: bigint | number
    DATE?: Date | string | null
    NOTIFICATIONSTATUS?: string | null
    NOTIFICATIONTYPE?: string | null
    ORDERID?: string | null
    TEXT?: string | null
    company?: companyCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    ID?: bigint | number
    DATE?: Date | string | null
    NOTIFICATIONSTATUS?: string | null
    NOTIFICATIONTYPE?: string | null
    ORDERID?: string | null
    TEXT?: string | null
    COMPANYID?: bigint | number | null
  }

  export type notificationUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NOTIFICATIONSTATUS?: NullableStringFieldUpdateOperationsInput | string | null
    NOTIFICATIONTYPE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    TEXT?: NullableStringFieldUpdateOperationsInput | string | null
    company?: companyUpdateOneWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NOTIFICATIONSTATUS?: NullableStringFieldUpdateOperationsInput | string | null
    NOTIFICATIONTYPE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    TEXT?: NullableStringFieldUpdateOperationsInput | string | null
    COMPANYID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type notificationCreateManyInput = {
    ID?: bigint | number
    DATE?: Date | string | null
    NOTIFICATIONSTATUS?: string | null
    NOTIFICATIONTYPE?: string | null
    ORDERID?: string | null
    TEXT?: string | null
    COMPANYID?: bigint | number | null
  }

  export type notificationUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NOTIFICATIONSTATUS?: NullableStringFieldUpdateOperationsInput | string | null
    NOTIFICATIONTYPE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    TEXT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NOTIFICATIONSTATUS?: NullableStringFieldUpdateOperationsInput | string | null
    NOTIFICATIONTYPE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    TEXT?: NullableStringFieldUpdateOperationsInput | string | null
    COMPANYID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type CompanyNullableRelationFilter = {
    is?: companyWhereInput | null
    isNot?: companyWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type accountCountOrderByAggregateInput = {
    ID?: SortOrder
    EMAIL?: SortOrder
    PASSWORD?: SortOrder
    ROLE?: SortOrder
    company_id?: SortOrder
  }

  export type accountAvgOrderByAggregateInput = {
    ID?: SortOrder
    ROLE?: SortOrder
    company_id?: SortOrder
  }

  export type accountMaxOrderByAggregateInput = {
    ID?: SortOrder
    EMAIL?: SortOrder
    PASSWORD?: SortOrder
    ROLE?: SortOrder
    company_id?: SortOrder
  }

  export type accountMinOrderByAggregateInput = {
    ID?: SortOrder
    EMAIL?: SortOrder
    PASSWORD?: SortOrder
    ROLE?: SortOrder
    company_id?: SortOrder
  }

  export type accountSumOrderByAggregateInput = {
    ID?: SortOrder
    ROLE?: SortOrder
    company_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AccountListRelationFilter = {
    every?: accountWhereInput
    some?: accountWhereInput
    none?: accountWhereInput
  }

  export type Company_known_companiesListRelationFilter = {
    every?: company_known_companiesWhereInput
    some?: company_known_companiesWhereInput
    none?: company_known_companiesWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type Company_paymentoptionsListRelationFilter = {
    every?: company_paymentoptionsWhereInput
    some?: company_paymentoptionsWhereInput
    none?: company_paymentoptionsWhereInput
  }

  export type Order_tableListRelationFilter = {
    every?: order_tableWhereInput
    some?: order_tableWhereInput
    none?: order_tableWhereInput
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type accountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_known_companiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_paymentoptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type order_tableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyCountOrderByAggregateInput = {
    ID?: SortOrder
    BANKACCOUNTNR?: SortOrder
    CUSTOMERSTART?: SortOrder
    ISACTIVE?: SortOrder
    LOGO?: SortOrder
    NAME?: SortOrder
    SECTOR?: SortOrder
    VATNUMBER?: SortOrder
    CITY?: SortOrder
    COUNTRY?: SortOrder
    NUMBER?: SortOrder
    STREET?: SortOrder
    ZIPCODE?: SortOrder
    EMAIL?: SortOrder
    PHONENUMBER?: SortOrder
  }

  export type companyAvgOrderByAggregateInput = {
    ID?: SortOrder
    BANKACCOUNTNR?: SortOrder
  }

  export type companyMaxOrderByAggregateInput = {
    ID?: SortOrder
    BANKACCOUNTNR?: SortOrder
    CUSTOMERSTART?: SortOrder
    ISACTIVE?: SortOrder
    LOGO?: SortOrder
    NAME?: SortOrder
    SECTOR?: SortOrder
    VATNUMBER?: SortOrder
    CITY?: SortOrder
    COUNTRY?: SortOrder
    NUMBER?: SortOrder
    STREET?: SortOrder
    ZIPCODE?: SortOrder
    EMAIL?: SortOrder
    PHONENUMBER?: SortOrder
  }

  export type companyMinOrderByAggregateInput = {
    ID?: SortOrder
    BANKACCOUNTNR?: SortOrder
    CUSTOMERSTART?: SortOrder
    ISACTIVE?: SortOrder
    LOGO?: SortOrder
    NAME?: SortOrder
    SECTOR?: SortOrder
    VATNUMBER?: SortOrder
    CITY?: SortOrder
    COUNTRY?: SortOrder
    NUMBER?: SortOrder
    STREET?: SortOrder
    ZIPCODE?: SortOrder
    EMAIL?: SortOrder
    PHONENUMBER?: SortOrder
  }

  export type companySumOrderByAggregateInput = {
    ID?: SortOrder
    BANKACCOUNTNR?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type CompanyRelationFilter = {
    is?: companyWhereInput
    isNot?: companyWhereInput
  }

  export type company_known_companiesCompany_idKnown_company_idCompoundUniqueInput = {
    company_id: bigint | number
    known_company_id: bigint | number
  }

  export type company_known_companiesCountOrderByAggregateInput = {
    company_id?: SortOrder
    known_company_id?: SortOrder
  }

  export type company_known_companiesAvgOrderByAggregateInput = {
    company_id?: SortOrder
    known_company_id?: SortOrder
  }

  export type company_known_companiesMaxOrderByAggregateInput = {
    company_id?: SortOrder
    known_company_id?: SortOrder
  }

  export type company_known_companiesMinOrderByAggregateInput = {
    company_id?: SortOrder
    known_company_id?: SortOrder
  }

  export type company_known_companiesSumOrderByAggregateInput = {
    company_id?: SortOrder
    known_company_id?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type company_paymentoptionsCompany_IDPAYMENTOPTIONSCompoundUniqueInput = {
    Company_ID: bigint | number
    PAYMENTOPTIONS: string
  }

  export type company_paymentoptionsCountOrderByAggregateInput = {
    Company_ID?: SortOrder
    PAYMENTOPTIONS?: SortOrder
  }

  export type company_paymentoptionsAvgOrderByAggregateInput = {
    Company_ID?: SortOrder
  }

  export type company_paymentoptionsMaxOrderByAggregateInput = {
    Company_ID?: SortOrder
    PAYMENTOPTIONS?: SortOrder
  }

  export type company_paymentoptionsMinOrderByAggregateInput = {
    Company_ID?: SortOrder
    PAYMENTOPTIONS?: SortOrder
  }

  export type company_paymentoptionsSumOrderByAggregateInput = {
    Company_ID?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type company_update_requestsCountOrderByAggregateInput = {
    ID?: SortOrder
    NEWBANKACCOUNTNR?: SortOrder
    NEWCUSTOMEREMAIL?: SortOrder
    NEWCUSTOMERPASSWORD?: SortOrder
    NEWCUSTOMERSTART?: SortOrder
    NEWLOGO?: SortOrder
    NEWNAME?: SortOrder
    NEWSECTOR?: SortOrder
    NEWSUPPLIEREMAIL?: SortOrder
    NEWSUPPLIERPASSWORD?: SortOrder
    NEWVATNUMBER?: SortOrder
    OLDVATNUMBER?: SortOrder
    REQUESTDATE?: SortOrder
    CITY?: SortOrder
    COUNTRY?: SortOrder
    NUMBER?: SortOrder
    STREET?: SortOrder
    ZIPCODE?: SortOrder
    EMAIL?: SortOrder
    PHONENUMBER?: SortOrder
  }

  export type company_update_requestsAvgOrderByAggregateInput = {
    ID?: SortOrder
    NEWBANKACCOUNTNR?: SortOrder
  }

  export type company_update_requestsMaxOrderByAggregateInput = {
    ID?: SortOrder
    NEWBANKACCOUNTNR?: SortOrder
    NEWCUSTOMEREMAIL?: SortOrder
    NEWCUSTOMERPASSWORD?: SortOrder
    NEWCUSTOMERSTART?: SortOrder
    NEWLOGO?: SortOrder
    NEWNAME?: SortOrder
    NEWSECTOR?: SortOrder
    NEWSUPPLIEREMAIL?: SortOrder
    NEWSUPPLIERPASSWORD?: SortOrder
    NEWVATNUMBER?: SortOrder
    OLDVATNUMBER?: SortOrder
    REQUESTDATE?: SortOrder
    CITY?: SortOrder
    COUNTRY?: SortOrder
    NUMBER?: SortOrder
    STREET?: SortOrder
    ZIPCODE?: SortOrder
    EMAIL?: SortOrder
    PHONENUMBER?: SortOrder
  }

  export type company_update_requestsMinOrderByAggregateInput = {
    ID?: SortOrder
    NEWBANKACCOUNTNR?: SortOrder
    NEWCUSTOMEREMAIL?: SortOrder
    NEWCUSTOMERPASSWORD?: SortOrder
    NEWCUSTOMERSTART?: SortOrder
    NEWLOGO?: SortOrder
    NEWNAME?: SortOrder
    NEWSECTOR?: SortOrder
    NEWSUPPLIEREMAIL?: SortOrder
    NEWSUPPLIERPASSWORD?: SortOrder
    NEWVATNUMBER?: SortOrder
    OLDVATNUMBER?: SortOrder
    REQUESTDATE?: SortOrder
    CITY?: SortOrder
    COUNTRY?: SortOrder
    NUMBER?: SortOrder
    STREET?: SortOrder
    ZIPCODE?: SortOrder
    EMAIL?: SortOrder
    PHONENUMBER?: SortOrder
  }

  export type company_update_requestsSumOrderByAggregateInput = {
    ID?: SortOrder
    NEWBANKACCOUNTNR?: SortOrder
  }

  export type companyupdaterequest_newpaymentoptionsCompanyUpdateRequest_IDNEWPAYMENTOPTIONSCompoundUniqueInput = {
    CompanyUpdateRequest_ID: bigint | number
    NEWPAYMENTOPTIONS: string
  }

  export type companyupdaterequest_newpaymentoptionsCountOrderByAggregateInput = {
    CompanyUpdateRequest_ID?: SortOrder
    NEWPAYMENTOPTIONS?: SortOrder
  }

  export type companyupdaterequest_newpaymentoptionsAvgOrderByAggregateInput = {
    CompanyUpdateRequest_ID?: SortOrder
  }

  export type companyupdaterequest_newpaymentoptionsMaxOrderByAggregateInput = {
    CompanyUpdateRequest_ID?: SortOrder
    NEWPAYMENTOPTIONS?: SortOrder
  }

  export type companyupdaterequest_newpaymentoptionsMinOrderByAggregateInput = {
    CompanyUpdateRequest_ID?: SortOrder
    NEWPAYMENTOPTIONS?: SortOrder
  }

  export type companyupdaterequest_newpaymentoptionsSumOrderByAggregateInput = {
    CompanyUpdateRequest_ID?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OrderitemListRelationFilter = {
    every?: orderitemWhereInput
    some?: orderitemWhereInput
    none?: orderitemWhereInput
  }

  export type orderitemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type order_tableCountOrderByAggregateInput = {
    ID?: SortOrder
    CURRENCY?: SortOrder
    DATE?: SortOrder
    LASTPAYMENTREMINDER?: SortOrder
    NAME?: SortOrder
    NETAMOUNT?: SortOrder
    ORDERDATETIME?: SortOrder
    ORDERID?: SortOrder
    ORDERREFERENCE?: SortOrder
    ORDERSTATUS?: SortOrder
    PAYMENTSTATUS?: SortOrder
    TAXAMOUNT?: SortOrder
    TOTALAMOUNT?: SortOrder
    FROMCOMPANY_ID?: SortOrder
    TOCOMPANY_ID?: SortOrder
  }

  export type order_tableAvgOrderByAggregateInput = {
    ID?: SortOrder
    NETAMOUNT?: SortOrder
    ORDERSTATUS?: SortOrder
    PAYMENTSTATUS?: SortOrder
    TAXAMOUNT?: SortOrder
    TOTALAMOUNT?: SortOrder
    FROMCOMPANY_ID?: SortOrder
    TOCOMPANY_ID?: SortOrder
  }

  export type order_tableMaxOrderByAggregateInput = {
    ID?: SortOrder
    CURRENCY?: SortOrder
    DATE?: SortOrder
    LASTPAYMENTREMINDER?: SortOrder
    NAME?: SortOrder
    NETAMOUNT?: SortOrder
    ORDERDATETIME?: SortOrder
    ORDERID?: SortOrder
    ORDERREFERENCE?: SortOrder
    ORDERSTATUS?: SortOrder
    PAYMENTSTATUS?: SortOrder
    TAXAMOUNT?: SortOrder
    TOTALAMOUNT?: SortOrder
    FROMCOMPANY_ID?: SortOrder
    TOCOMPANY_ID?: SortOrder
  }

  export type order_tableMinOrderByAggregateInput = {
    ID?: SortOrder
    CURRENCY?: SortOrder
    DATE?: SortOrder
    LASTPAYMENTREMINDER?: SortOrder
    NAME?: SortOrder
    NETAMOUNT?: SortOrder
    ORDERDATETIME?: SortOrder
    ORDERID?: SortOrder
    ORDERREFERENCE?: SortOrder
    ORDERSTATUS?: SortOrder
    PAYMENTSTATUS?: SortOrder
    TAXAMOUNT?: SortOrder
    TOTALAMOUNT?: SortOrder
    FROMCOMPANY_ID?: SortOrder
    TOCOMPANY_ID?: SortOrder
  }

  export type order_tableSumOrderByAggregateInput = {
    ID?: SortOrder
    NETAMOUNT?: SortOrder
    ORDERSTATUS?: SortOrder
    PAYMENTSTATUS?: SortOrder
    TAXAMOUNT?: SortOrder
    TOTALAMOUNT?: SortOrder
    FROMCOMPANY_ID?: SortOrder
    TOCOMPANY_ID?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Order_tableNullableRelationFilter = {
    is?: order_tableWhereInput | null
    isNot?: order_tableWhereInput | null
  }

  export type ProductNullableRelationFilter = {
    is?: productWhereInput | null
    isNot?: productWhereInput | null
  }

  export type orderitemCountOrderByAggregateInput = {
    ID?: SortOrder
    INSTOCK?: SortOrder
    NAME?: SortOrder
    ORDERID?: SortOrder
    ORDERITEMID?: SortOrder
    QUANTITY?: SortOrder
    SYNCID?: SortOrder
    TOTAL?: SortOrder
    UNITOFMEASUREID?: SortOrder
    UNITPRICE?: SortOrder
    FROMORDER_ID?: SortOrder
    PRODUCT_ID?: SortOrder
  }

  export type orderitemAvgOrderByAggregateInput = {
    ID?: SortOrder
    ORDERID?: SortOrder
    ORDERITEMID?: SortOrder
    QUANTITY?: SortOrder
    SYNCID?: SortOrder
    TOTAL?: SortOrder
    UNITPRICE?: SortOrder
    FROMORDER_ID?: SortOrder
    PRODUCT_ID?: SortOrder
  }

  export type orderitemMaxOrderByAggregateInput = {
    ID?: SortOrder
    INSTOCK?: SortOrder
    NAME?: SortOrder
    ORDERID?: SortOrder
    ORDERITEMID?: SortOrder
    QUANTITY?: SortOrder
    SYNCID?: SortOrder
    TOTAL?: SortOrder
    UNITOFMEASUREID?: SortOrder
    UNITPRICE?: SortOrder
    FROMORDER_ID?: SortOrder
    PRODUCT_ID?: SortOrder
  }

  export type orderitemMinOrderByAggregateInput = {
    ID?: SortOrder
    INSTOCK?: SortOrder
    NAME?: SortOrder
    ORDERID?: SortOrder
    ORDERITEMID?: SortOrder
    QUANTITY?: SortOrder
    SYNCID?: SortOrder
    TOTAL?: SortOrder
    UNITOFMEASUREID?: SortOrder
    UNITPRICE?: SortOrder
    FROMORDER_ID?: SortOrder
    PRODUCT_ID?: SortOrder
  }

  export type orderitemSumOrderByAggregateInput = {
    ID?: SortOrder
    ORDERID?: SortOrder
    ORDERITEMID?: SortOrder
    QUANTITY?: SortOrder
    SYNCID?: SortOrder
    TOTAL?: SortOrder
    UNITPRICE?: SortOrder
    FROMORDER_ID?: SortOrder
    PRODUCT_ID?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type productCountOrderByAggregateInput = {
    ID?: SortOrder
    DESCRIPTION?: SortOrder
    NAME?: SortOrder
    PRICE?: SortOrder
    PRODUCTAVAILABILITY?: SortOrder
    PRODUCTCATEGORYID?: SortOrder
    PRODUCTID?: SortOrder
    PRODUCTUNITOFMEASUREID?: SortOrder
    SYNCID?: SortOrder
    FROMCOMPANY_ID?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    ID?: SortOrder
    PRICE?: SortOrder
    SYNCID?: SortOrder
    FROMCOMPANY_ID?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    ID?: SortOrder
    DESCRIPTION?: SortOrder
    NAME?: SortOrder
    PRICE?: SortOrder
    PRODUCTAVAILABILITY?: SortOrder
    PRODUCTCATEGORYID?: SortOrder
    PRODUCTID?: SortOrder
    PRODUCTUNITOFMEASUREID?: SortOrder
    SYNCID?: SortOrder
    FROMCOMPANY_ID?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    ID?: SortOrder
    DESCRIPTION?: SortOrder
    NAME?: SortOrder
    PRICE?: SortOrder
    PRODUCTAVAILABILITY?: SortOrder
    PRODUCTCATEGORYID?: SortOrder
    PRODUCTID?: SortOrder
    PRODUCTUNITOFMEASUREID?: SortOrder
    SYNCID?: SortOrder
    FROMCOMPANY_ID?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    ID?: SortOrder
    PRICE?: SortOrder
    SYNCID?: SortOrder
    FROMCOMPANY_ID?: SortOrder
  }

  export type notificationCountOrderByAggregateInput = {
    ID?: SortOrder
    DATE?: SortOrder
    NOTIFICATIONSTATUS?: SortOrder
    NOTIFICATIONTYPE?: SortOrder
    ORDERID?: SortOrder
    TEXT?: SortOrder
    COMPANYID?: SortOrder
  }

  export type notificationAvgOrderByAggregateInput = {
    ID?: SortOrder
    COMPANYID?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    ID?: SortOrder
    DATE?: SortOrder
    NOTIFICATIONSTATUS?: SortOrder
    NOTIFICATIONTYPE?: SortOrder
    ORDERID?: SortOrder
    TEXT?: SortOrder
    COMPANYID?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    ID?: SortOrder
    DATE?: SortOrder
    NOTIFICATIONSTATUS?: SortOrder
    NOTIFICATIONTYPE?: SortOrder
    ORDERID?: SortOrder
    TEXT?: SortOrder
    COMPANYID?: SortOrder
  }

  export type notificationSumOrderByAggregateInput = {
    ID?: SortOrder
    COMPANYID?: SortOrder
  }

  export type companyCreateNestedOneWithoutAccountInput = {
    create?: XOR<companyCreateWithoutAccountInput, companyUncheckedCreateWithoutAccountInput>
    connectOrCreate?: companyCreateOrConnectWithoutAccountInput
    connect?: companyWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companyUpdateOneWithoutAccountNestedInput = {
    create?: XOR<companyCreateWithoutAccountInput, companyUncheckedCreateWithoutAccountInput>
    connectOrCreate?: companyCreateOrConnectWithoutAccountInput
    upsert?: companyUpsertWithoutAccountInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutAccountInput, companyUpdateWithoutAccountInput>, companyUncheckedUpdateWithoutAccountInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type accountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<accountCreateWithoutCompanyInput, accountUncheckedCreateWithoutCompanyInput> | accountCreateWithoutCompanyInput[] | accountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: accountCreateOrConnectWithoutCompanyInput | accountCreateOrConnectWithoutCompanyInput[]
    createMany?: accountCreateManyCompanyInputEnvelope
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[]
  }

  export type company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInputEnvelope
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
  }

  export type company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInputEnvelope
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<notificationCreateWithoutCompanyInput, notificationUncheckedCreateWithoutCompanyInput> | notificationCreateWithoutCompanyInput[] | notificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutCompanyInput | notificationCreateOrConnectWithoutCompanyInput[]
    createMany?: notificationCreateManyCompanyInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type company_paymentoptionsCreateNestedManyWithoutCompanyInput = {
    create?: XOR<company_paymentoptionsCreateWithoutCompanyInput, company_paymentoptionsUncheckedCreateWithoutCompanyInput> | company_paymentoptionsCreateWithoutCompanyInput[] | company_paymentoptionsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_paymentoptionsCreateOrConnectWithoutCompanyInput | company_paymentoptionsCreateOrConnectWithoutCompanyInput[]
    createMany?: company_paymentoptionsCreateManyCompanyInputEnvelope
    connect?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
  }

  export type order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInputEnvelope
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
  }

  export type order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInputEnvelope
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
  }

  export type productCreateNestedManyWithoutCompanyInput = {
    create?: XOR<productCreateWithoutCompanyInput, productUncheckedCreateWithoutCompanyInput> | productCreateWithoutCompanyInput[] | productUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: productCreateOrConnectWithoutCompanyInput | productCreateOrConnectWithoutCompanyInput[]
    createMany?: productCreateManyCompanyInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type accountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<accountCreateWithoutCompanyInput, accountUncheckedCreateWithoutCompanyInput> | accountCreateWithoutCompanyInput[] | accountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: accountCreateOrConnectWithoutCompanyInput | accountCreateOrConnectWithoutCompanyInput[]
    createMany?: accountCreateManyCompanyInputEnvelope
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[]
  }

  export type company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInputEnvelope
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
  }

  export type company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInputEnvelope
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<notificationCreateWithoutCompanyInput, notificationUncheckedCreateWithoutCompanyInput> | notificationCreateWithoutCompanyInput[] | notificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutCompanyInput | notificationCreateOrConnectWithoutCompanyInput[]
    createMany?: notificationCreateManyCompanyInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<company_paymentoptionsCreateWithoutCompanyInput, company_paymentoptionsUncheckedCreateWithoutCompanyInput> | company_paymentoptionsCreateWithoutCompanyInput[] | company_paymentoptionsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_paymentoptionsCreateOrConnectWithoutCompanyInput | company_paymentoptionsCreateOrConnectWithoutCompanyInput[]
    createMany?: company_paymentoptionsCreateManyCompanyInputEnvelope
    connect?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
  }

  export type order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInputEnvelope
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
  }

  export type order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInputEnvelope
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<productCreateWithoutCompanyInput, productUncheckedCreateWithoutCompanyInput> | productCreateWithoutCompanyInput[] | productUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: productCreateOrConnectWithoutCompanyInput | productCreateOrConnectWithoutCompanyInput[]
    createMany?: productCreateManyCompanyInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type accountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<accountCreateWithoutCompanyInput, accountUncheckedCreateWithoutCompanyInput> | accountCreateWithoutCompanyInput[] | accountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: accountCreateOrConnectWithoutCompanyInput | accountCreateOrConnectWithoutCompanyInput[]
    upsert?: accountUpsertWithWhereUniqueWithoutCompanyInput | accountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: accountCreateManyCompanyInputEnvelope
    set?: accountWhereUniqueInput | accountWhereUniqueInput[]
    disconnect?: accountWhereUniqueInput | accountWhereUniqueInput[]
    delete?: accountWhereUniqueInput | accountWhereUniqueInput[]
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[]
    update?: accountUpdateWithWhereUniqueWithoutCompanyInput | accountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: accountUpdateManyWithWhereWithoutCompanyInput | accountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: accountScalarWhereInput | accountScalarWhereInput[]
  }

  export type company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput[]
    upsert?: company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInputEnvelope
    set?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    disconnect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    delete?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    update?: company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput[]
    updateMany?: company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_company_idTocompanyInput[]
    deleteMany?: company_known_companiesScalarWhereInput | company_known_companiesScalarWhereInput[]
  }

  export type company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    upsert?: company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInputEnvelope
    set?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    disconnect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    delete?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    update?: company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    updateMany?: company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    deleteMany?: company_known_companiesScalarWhereInput | company_known_companiesScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<notificationCreateWithoutCompanyInput, notificationUncheckedCreateWithoutCompanyInput> | notificationCreateWithoutCompanyInput[] | notificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutCompanyInput | notificationCreateOrConnectWithoutCompanyInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutCompanyInput | notificationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: notificationCreateManyCompanyInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutCompanyInput | notificationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutCompanyInput | notificationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type company_paymentoptionsUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<company_paymentoptionsCreateWithoutCompanyInput, company_paymentoptionsUncheckedCreateWithoutCompanyInput> | company_paymentoptionsCreateWithoutCompanyInput[] | company_paymentoptionsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_paymentoptionsCreateOrConnectWithoutCompanyInput | company_paymentoptionsCreateOrConnectWithoutCompanyInput[]
    upsert?: company_paymentoptionsUpsertWithWhereUniqueWithoutCompanyInput | company_paymentoptionsUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: company_paymentoptionsCreateManyCompanyInputEnvelope
    set?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    disconnect?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    delete?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    connect?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    update?: company_paymentoptionsUpdateWithWhereUniqueWithoutCompanyInput | company_paymentoptionsUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: company_paymentoptionsUpdateManyWithWhereWithoutCompanyInput | company_paymentoptionsUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: company_paymentoptionsScalarWhereInput | company_paymentoptionsScalarWhereInput[]
  }

  export type order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    upsert?: order_tableUpsertWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableUpsertWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInputEnvelope
    set?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    disconnect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    delete?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    update?: order_tableUpdateWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableUpdateWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    updateMany?: order_tableUpdateManyWithWhereWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableUpdateManyWithWhereWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    deleteMany?: order_tableScalarWhereInput | order_tableScalarWhereInput[]
  }

  export type order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    upsert?: order_tableUpsertWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableUpsertWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInputEnvelope
    set?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    disconnect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    delete?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    update?: order_tableUpdateWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableUpdateWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    updateMany?: order_tableUpdateManyWithWhereWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableUpdateManyWithWhereWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    deleteMany?: order_tableScalarWhereInput | order_tableScalarWhereInput[]
  }

  export type productUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<productCreateWithoutCompanyInput, productUncheckedCreateWithoutCompanyInput> | productCreateWithoutCompanyInput[] | productUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: productCreateOrConnectWithoutCompanyInput | productCreateOrConnectWithoutCompanyInput[]
    upsert?: productUpsertWithWhereUniqueWithoutCompanyInput | productUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: productCreateManyCompanyInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutCompanyInput | productUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: productUpdateManyWithWhereWithoutCompanyInput | productUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type accountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<accountCreateWithoutCompanyInput, accountUncheckedCreateWithoutCompanyInput> | accountCreateWithoutCompanyInput[] | accountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: accountCreateOrConnectWithoutCompanyInput | accountCreateOrConnectWithoutCompanyInput[]
    upsert?: accountUpsertWithWhereUniqueWithoutCompanyInput | accountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: accountCreateManyCompanyInputEnvelope
    set?: accountWhereUniqueInput | accountWhereUniqueInput[]
    disconnect?: accountWhereUniqueInput | accountWhereUniqueInput[]
    delete?: accountWhereUniqueInput | accountWhereUniqueInput[]
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[]
    update?: accountUpdateWithWhereUniqueWithoutCompanyInput | accountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: accountUpdateManyWithWhereWithoutCompanyInput | accountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: accountScalarWhereInput | accountScalarWhereInput[]
  }

  export type company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput[]
    upsert?: company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInputEnvelope
    set?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    disconnect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    delete?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    update?: company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput[]
    updateMany?: company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_company_idTocompanyInput | company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_company_idTocompanyInput[]
    deleteMany?: company_known_companiesScalarWhereInput | company_known_companiesScalarWhereInput[]
  }

  export type company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput = {
    create?: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput> | company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[] | company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    connectOrCreate?: company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    upsert?: company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    createMany?: company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInputEnvelope
    set?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    disconnect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    delete?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    connect?: company_known_companiesWhereUniqueInput | company_known_companiesWhereUniqueInput[]
    update?: company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    updateMany?: company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_known_company_idTocompanyInput[]
    deleteMany?: company_known_companiesScalarWhereInput | company_known_companiesScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<notificationCreateWithoutCompanyInput, notificationUncheckedCreateWithoutCompanyInput> | notificationCreateWithoutCompanyInput[] | notificationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutCompanyInput | notificationCreateOrConnectWithoutCompanyInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutCompanyInput | notificationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: notificationCreateManyCompanyInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutCompanyInput | notificationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutCompanyInput | notificationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<company_paymentoptionsCreateWithoutCompanyInput, company_paymentoptionsUncheckedCreateWithoutCompanyInput> | company_paymentoptionsCreateWithoutCompanyInput[] | company_paymentoptionsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_paymentoptionsCreateOrConnectWithoutCompanyInput | company_paymentoptionsCreateOrConnectWithoutCompanyInput[]
    upsert?: company_paymentoptionsUpsertWithWhereUniqueWithoutCompanyInput | company_paymentoptionsUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: company_paymentoptionsCreateManyCompanyInputEnvelope
    set?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    disconnect?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    delete?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    connect?: company_paymentoptionsWhereUniqueInput | company_paymentoptionsWhereUniqueInput[]
    update?: company_paymentoptionsUpdateWithWhereUniqueWithoutCompanyInput | company_paymentoptionsUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: company_paymentoptionsUpdateManyWithWhereWithoutCompanyInput | company_paymentoptionsUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: company_paymentoptionsScalarWhereInput | company_paymentoptionsScalarWhereInput[]
  }

  export type order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    upsert?: order_tableUpsertWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableUpsertWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInputEnvelope
    set?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    disconnect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    delete?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    update?: order_tableUpdateWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableUpdateWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    updateMany?: order_tableUpdateManyWithWhereWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableUpdateManyWithWhereWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    deleteMany?: order_tableScalarWhereInput | order_tableScalarWhereInput[]
  }

  export type order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput = {
    create?: XOR<order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput> | order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[] | order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    connectOrCreate?: order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    upsert?: order_tableUpsertWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableUpsertWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    createMany?: order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInputEnvelope
    set?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    disconnect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    delete?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    connect?: order_tableWhereUniqueInput | order_tableWhereUniqueInput[]
    update?: order_tableUpdateWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableUpdateWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    updateMany?: order_tableUpdateManyWithWhereWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableUpdateManyWithWhereWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    deleteMany?: order_tableScalarWhereInput | order_tableScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<productCreateWithoutCompanyInput, productUncheckedCreateWithoutCompanyInput> | productCreateWithoutCompanyInput[] | productUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: productCreateOrConnectWithoutCompanyInput | productCreateOrConnectWithoutCompanyInput[]
    upsert?: productUpsertWithWhereUniqueWithoutCompanyInput | productUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: productCreateManyCompanyInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutCompanyInput | productUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: productUpdateManyWithWhereWithoutCompanyInput | productUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type companyCreateNestedOneWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    create?: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput
    connect?: companyWhereUniqueInput
  }

  export type companyCreateNestedOneWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    create?: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput
    connect?: companyWhereUniqueInput
  }

  export type companyUpdateOneRequiredWithoutCompany_known_companies_company_known_companies_company_idTocompanyNestedInput = {
    create?: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput
    upsert?: companyUpsertWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput, companyUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>, companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>
  }

  export type companyUpdateOneRequiredWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyNestedInput = {
    create?: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput
    upsert?: companyUpsertWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput, companyUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>, companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>
  }

  export type companyCreateNestedOneWithoutCompany_paymentoptionsInput = {
    create?: XOR<companyCreateWithoutCompany_paymentoptionsInput, companyUncheckedCreateWithoutCompany_paymentoptionsInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_paymentoptionsInput
    connect?: companyWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type companyUpdateOneWithoutCompany_paymentoptionsNestedInput = {
    create?: XOR<companyCreateWithoutCompany_paymentoptionsInput, companyUncheckedCreateWithoutCompany_paymentoptionsInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_paymentoptionsInput
    upsert?: companyUpsertWithoutCompany_paymentoptionsInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutCompany_paymentoptionsInput, companyUpdateWithoutCompany_paymentoptionsInput>, companyUncheckedUpdateWithoutCompany_paymentoptionsInput>
  }

  export type companyCreateNestedOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    create?: XOR<companyCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput
    connect?: companyWhereUniqueInput
  }

  export type companyCreateNestedOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    create?: XOR<companyCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput
    connect?: companyWhereUniqueInput
  }

  export type orderitemCreateNestedManyWithoutOrder_tableInput = {
    create?: XOR<orderitemCreateWithoutOrder_tableInput, orderitemUncheckedCreateWithoutOrder_tableInput> | orderitemCreateWithoutOrder_tableInput[] | orderitemUncheckedCreateWithoutOrder_tableInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutOrder_tableInput | orderitemCreateOrConnectWithoutOrder_tableInput[]
    createMany?: orderitemCreateManyOrder_tableInputEnvelope
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
  }

  export type orderitemUncheckedCreateNestedManyWithoutOrder_tableInput = {
    create?: XOR<orderitemCreateWithoutOrder_tableInput, orderitemUncheckedCreateWithoutOrder_tableInput> | orderitemCreateWithoutOrder_tableInput[] | orderitemUncheckedCreateWithoutOrder_tableInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutOrder_tableInput | orderitemCreateOrConnectWithoutOrder_tableInput[]
    createMany?: orderitemCreateManyOrder_tableInputEnvelope
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companyUpdateOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyNestedInput = {
    create?: XOR<companyCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput
    upsert?: companyUpsertWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput, companyUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>, companyUncheckedUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>
  }

  export type companyUpdateOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyNestedInput = {
    create?: XOR<companyCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>
    connectOrCreate?: companyCreateOrConnectWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput
    upsert?: companyUpsertWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput, companyUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>, companyUncheckedUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>
  }

  export type orderitemUpdateManyWithoutOrder_tableNestedInput = {
    create?: XOR<orderitemCreateWithoutOrder_tableInput, orderitemUncheckedCreateWithoutOrder_tableInput> | orderitemCreateWithoutOrder_tableInput[] | orderitemUncheckedCreateWithoutOrder_tableInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutOrder_tableInput | orderitemCreateOrConnectWithoutOrder_tableInput[]
    upsert?: orderitemUpsertWithWhereUniqueWithoutOrder_tableInput | orderitemUpsertWithWhereUniqueWithoutOrder_tableInput[]
    createMany?: orderitemCreateManyOrder_tableInputEnvelope
    set?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    disconnect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    delete?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    update?: orderitemUpdateWithWhereUniqueWithoutOrder_tableInput | orderitemUpdateWithWhereUniqueWithoutOrder_tableInput[]
    updateMany?: orderitemUpdateManyWithWhereWithoutOrder_tableInput | orderitemUpdateManyWithWhereWithoutOrder_tableInput[]
    deleteMany?: orderitemScalarWhereInput | orderitemScalarWhereInput[]
  }

  export type orderitemUncheckedUpdateManyWithoutOrder_tableNestedInput = {
    create?: XOR<orderitemCreateWithoutOrder_tableInput, orderitemUncheckedCreateWithoutOrder_tableInput> | orderitemCreateWithoutOrder_tableInput[] | orderitemUncheckedCreateWithoutOrder_tableInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutOrder_tableInput | orderitemCreateOrConnectWithoutOrder_tableInput[]
    upsert?: orderitemUpsertWithWhereUniqueWithoutOrder_tableInput | orderitemUpsertWithWhereUniqueWithoutOrder_tableInput[]
    createMany?: orderitemCreateManyOrder_tableInputEnvelope
    set?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    disconnect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    delete?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    update?: orderitemUpdateWithWhereUniqueWithoutOrder_tableInput | orderitemUpdateWithWhereUniqueWithoutOrder_tableInput[]
    updateMany?: orderitemUpdateManyWithWhereWithoutOrder_tableInput | orderitemUpdateManyWithWhereWithoutOrder_tableInput[]
    deleteMany?: orderitemScalarWhereInput | orderitemScalarWhereInput[]
  }

  export type order_tableCreateNestedOneWithoutOrderitemInput = {
    create?: XOR<order_tableCreateWithoutOrderitemInput, order_tableUncheckedCreateWithoutOrderitemInput>
    connectOrCreate?: order_tableCreateOrConnectWithoutOrderitemInput
    connect?: order_tableWhereUniqueInput
  }

  export type productCreateNestedOneWithoutOrderitemInput = {
    create?: XOR<productCreateWithoutOrderitemInput, productUncheckedCreateWithoutOrderitemInput>
    connectOrCreate?: productCreateOrConnectWithoutOrderitemInput
    connect?: productWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type order_tableUpdateOneWithoutOrderitemNestedInput = {
    create?: XOR<order_tableCreateWithoutOrderitemInput, order_tableUncheckedCreateWithoutOrderitemInput>
    connectOrCreate?: order_tableCreateOrConnectWithoutOrderitemInput
    upsert?: order_tableUpsertWithoutOrderitemInput
    disconnect?: order_tableWhereInput | boolean
    delete?: order_tableWhereInput | boolean
    connect?: order_tableWhereUniqueInput
    update?: XOR<XOR<order_tableUpdateToOneWithWhereWithoutOrderitemInput, order_tableUpdateWithoutOrderitemInput>, order_tableUncheckedUpdateWithoutOrderitemInput>
  }

  export type productUpdateOneWithoutOrderitemNestedInput = {
    create?: XOR<productCreateWithoutOrderitemInput, productUncheckedCreateWithoutOrderitemInput>
    connectOrCreate?: productCreateOrConnectWithoutOrderitemInput
    upsert?: productUpsertWithoutOrderitemInput
    disconnect?: productWhereInput | boolean
    delete?: productWhereInput | boolean
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutOrderitemInput, productUpdateWithoutOrderitemInput>, productUncheckedUpdateWithoutOrderitemInput>
  }

  export type orderitemCreateNestedManyWithoutProductInput = {
    create?: XOR<orderitemCreateWithoutProductInput, orderitemUncheckedCreateWithoutProductInput> | orderitemCreateWithoutProductInput[] | orderitemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutProductInput | orderitemCreateOrConnectWithoutProductInput[]
    createMany?: orderitemCreateManyProductInputEnvelope
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
  }

  export type companyCreateNestedOneWithoutProductInput = {
    create?: XOR<companyCreateWithoutProductInput, companyUncheckedCreateWithoutProductInput>
    connectOrCreate?: companyCreateOrConnectWithoutProductInput
    connect?: companyWhereUniqueInput
  }

  export type orderitemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<orderitemCreateWithoutProductInput, orderitemUncheckedCreateWithoutProductInput> | orderitemCreateWithoutProductInput[] | orderitemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutProductInput | orderitemCreateOrConnectWithoutProductInput[]
    createMany?: orderitemCreateManyProductInputEnvelope
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
  }

  export type orderitemUpdateManyWithoutProductNestedInput = {
    create?: XOR<orderitemCreateWithoutProductInput, orderitemUncheckedCreateWithoutProductInput> | orderitemCreateWithoutProductInput[] | orderitemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutProductInput | orderitemCreateOrConnectWithoutProductInput[]
    upsert?: orderitemUpsertWithWhereUniqueWithoutProductInput | orderitemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: orderitemCreateManyProductInputEnvelope
    set?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    disconnect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    delete?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    update?: orderitemUpdateWithWhereUniqueWithoutProductInput | orderitemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: orderitemUpdateManyWithWhereWithoutProductInput | orderitemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: orderitemScalarWhereInput | orderitemScalarWhereInput[]
  }

  export type companyUpdateOneWithoutProductNestedInput = {
    create?: XOR<companyCreateWithoutProductInput, companyUncheckedCreateWithoutProductInput>
    connectOrCreate?: companyCreateOrConnectWithoutProductInput
    upsert?: companyUpsertWithoutProductInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutProductInput, companyUpdateWithoutProductInput>, companyUncheckedUpdateWithoutProductInput>
  }

  export type orderitemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<orderitemCreateWithoutProductInput, orderitemUncheckedCreateWithoutProductInput> | orderitemCreateWithoutProductInput[] | orderitemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderitemCreateOrConnectWithoutProductInput | orderitemCreateOrConnectWithoutProductInput[]
    upsert?: orderitemUpsertWithWhereUniqueWithoutProductInput | orderitemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: orderitemCreateManyProductInputEnvelope
    set?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    disconnect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    delete?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    connect?: orderitemWhereUniqueInput | orderitemWhereUniqueInput[]
    update?: orderitemUpdateWithWhereUniqueWithoutProductInput | orderitemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: orderitemUpdateManyWithWhereWithoutProductInput | orderitemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: orderitemScalarWhereInput | orderitemScalarWhereInput[]
  }

  export type companyCreateNestedOneWithoutNotificationInput = {
    create?: XOR<companyCreateWithoutNotificationInput, companyUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: companyCreateOrConnectWithoutNotificationInput
    connect?: companyWhereUniqueInput
  }

  export type companyUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<companyCreateWithoutNotificationInput, companyUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: companyCreateOrConnectWithoutNotificationInput
    upsert?: companyUpsertWithoutNotificationInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutNotificationInput, companyUpdateWithoutNotificationInput>, companyUncheckedUpdateWithoutNotificationInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type companyCreateWithoutAccountInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutAccountInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutAccountInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutAccountInput, companyUncheckedCreateWithoutAccountInput>
  }

  export type companyUpsertWithoutAccountInput = {
    update: XOR<companyUpdateWithoutAccountInput, companyUncheckedUpdateWithoutAccountInput>
    create: XOR<companyCreateWithoutAccountInput, companyUncheckedCreateWithoutAccountInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutAccountInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutAccountInput, companyUncheckedUpdateWithoutAccountInput>
  }

  export type companyUpdateWithoutAccountInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutAccountInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type accountCreateWithoutCompanyInput = {
    ID?: bigint | number
    EMAIL?: string | null
    PASSWORD?: string | null
    ROLE?: number | null
  }

  export type accountUncheckedCreateWithoutCompanyInput = {
    ID?: bigint | number
    EMAIL?: string | null
    PASSWORD?: string | null
    ROLE?: number | null
  }

  export type accountCreateOrConnectWithoutCompanyInput = {
    where: accountWhereUniqueInput
    create: XOR<accountCreateWithoutCompanyInput, accountUncheckedCreateWithoutCompanyInput>
  }

  export type accountCreateManyCompanyInputEnvelope = {
    data: accountCreateManyCompanyInput | accountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput = {
    company_company_known_companies_known_company_idTocompany: companyCreateNestedOneWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput
  }

  export type company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput = {
    known_company_id: bigint | number
  }

  export type company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_company_idTocompanyInput = {
    where: company_known_companiesWhereUniqueInput
    create: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput>
  }

  export type company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInputEnvelope = {
    data: company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInput | company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInput[]
    skipDuplicates?: boolean
  }

  export type company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    company_company_known_companies_company_idTocompany: companyCreateNestedOneWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput
  }

  export type company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    company_id: bigint | number
  }

  export type company_known_companiesCreateOrConnectWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    where: company_known_companiesWhereUniqueInput
    create: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput>
  }

  export type company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInputEnvelope = {
    data: company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInput | company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutCompanyInput = {
    ID?: bigint | number
    DATE?: Date | string | null
    NOTIFICATIONSTATUS?: string | null
    NOTIFICATIONTYPE?: string | null
    ORDERID?: string | null
    TEXT?: string | null
  }

  export type notificationUncheckedCreateWithoutCompanyInput = {
    ID?: bigint | number
    DATE?: Date | string | null
    NOTIFICATIONSTATUS?: string | null
    NOTIFICATIONTYPE?: string | null
    ORDERID?: string | null
    TEXT?: string | null
  }

  export type notificationCreateOrConnectWithoutCompanyInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutCompanyInput, notificationUncheckedCreateWithoutCompanyInput>
  }

  export type notificationCreateManyCompanyInputEnvelope = {
    data: notificationCreateManyCompanyInput | notificationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type company_paymentoptionsCreateWithoutCompanyInput = {
    PAYMENTOPTIONS: string
  }

  export type company_paymentoptionsUncheckedCreateWithoutCompanyInput = {
    PAYMENTOPTIONS: string
  }

  export type company_paymentoptionsCreateOrConnectWithoutCompanyInput = {
    where: company_paymentoptionsWhereUniqueInput
    create: XOR<company_paymentoptionsCreateWithoutCompanyInput, company_paymentoptionsUncheckedCreateWithoutCompanyInput>
  }

  export type company_paymentoptionsCreateManyCompanyInputEnvelope = {
    data: company_paymentoptionsCreateManyCompanyInput | company_paymentoptionsCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    company_order_table_TOCOMPANY_IDTocompany?: companyCreateNestedOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput
    orderitem?: orderitemCreateNestedManyWithoutOrder_tableInput
  }

  export type order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    TOCOMPANY_ID?: bigint | number | null
    orderitem?: orderitemUncheckedCreateNestedManyWithoutOrder_tableInput
  }

  export type order_tableCreateOrConnectWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    where: order_tableWhereUniqueInput
    create: XOR<order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput>
  }

  export type order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInputEnvelope = {
    data: order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInput | order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInput[]
    skipDuplicates?: boolean
  }

  export type order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    company_order_table_FROMCOMPANY_IDTocompany?: companyCreateNestedOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput
    orderitem?: orderitemCreateNestedManyWithoutOrder_tableInput
  }

  export type order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    FROMCOMPANY_ID?: bigint | number | null
    orderitem?: orderitemUncheckedCreateNestedManyWithoutOrder_tableInput
  }

  export type order_tableCreateOrConnectWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    where: order_tableWhereUniqueInput
    create: XOR<order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput>
  }

  export type order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInputEnvelope = {
    data: order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInput | order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInput[]
    skipDuplicates?: boolean
  }

  export type productCreateWithoutCompanyInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
    orderitem?: orderitemCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutCompanyInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
    orderitem?: orderitemUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCompanyInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCompanyInput, productUncheckedCreateWithoutCompanyInput>
  }

  export type productCreateManyCompanyInputEnvelope = {
    data: productCreateManyCompanyInput | productCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type accountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: accountWhereUniqueInput
    update: XOR<accountUpdateWithoutCompanyInput, accountUncheckedUpdateWithoutCompanyInput>
    create: XOR<accountCreateWithoutCompanyInput, accountUncheckedCreateWithoutCompanyInput>
  }

  export type accountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: accountWhereUniqueInput
    data: XOR<accountUpdateWithoutCompanyInput, accountUncheckedUpdateWithoutCompanyInput>
  }

  export type accountUpdateManyWithWhereWithoutCompanyInput = {
    where: accountScalarWhereInput
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type accountScalarWhereInput = {
    AND?: accountScalarWhereInput | accountScalarWhereInput[]
    OR?: accountScalarWhereInput[]
    NOT?: accountScalarWhereInput | accountScalarWhereInput[]
    ID?: BigIntFilter<"account"> | bigint | number
    EMAIL?: StringNullableFilter<"account"> | string | null
    PASSWORD?: StringNullableFilter<"account"> | string | null
    ROLE?: IntNullableFilter<"account"> | number | null
    company_id?: BigIntNullableFilter<"account"> | bigint | number | null
  }

  export type company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput = {
    where: company_known_companiesWhereUniqueInput
    update: XOR<company_known_companiesUpdateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedUpdateWithoutCompany_company_known_companies_company_idTocompanyInput>
    create: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_company_idTocompanyInput>
  }

  export type company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_company_idTocompanyInput = {
    where: company_known_companiesWhereUniqueInput
    data: XOR<company_known_companiesUpdateWithoutCompany_company_known_companies_company_idTocompanyInput, company_known_companiesUncheckedUpdateWithoutCompany_company_known_companies_company_idTocompanyInput>
  }

  export type company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_company_idTocompanyInput = {
    where: company_known_companiesScalarWhereInput
    data: XOR<company_known_companiesUpdateManyMutationInput, company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyInput>
  }

  export type company_known_companiesScalarWhereInput = {
    AND?: company_known_companiesScalarWhereInput | company_known_companiesScalarWhereInput[]
    OR?: company_known_companiesScalarWhereInput[]
    NOT?: company_known_companiesScalarWhereInput | company_known_companiesScalarWhereInput[]
    company_id?: BigIntFilter<"company_known_companies"> | bigint | number
    known_company_id?: BigIntFilter<"company_known_companies"> | bigint | number
  }

  export type company_known_companiesUpsertWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    where: company_known_companiesWhereUniqueInput
    update: XOR<company_known_companiesUpdateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedUpdateWithoutCompany_company_known_companies_known_company_idTocompanyInput>
    create: XOR<company_known_companiesCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedCreateWithoutCompany_company_known_companies_known_company_idTocompanyInput>
  }

  export type company_known_companiesUpdateWithWhereUniqueWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    where: company_known_companiesWhereUniqueInput
    data: XOR<company_known_companiesUpdateWithoutCompany_company_known_companies_known_company_idTocompanyInput, company_known_companiesUncheckedUpdateWithoutCompany_company_known_companies_known_company_idTocompanyInput>
  }

  export type company_known_companiesUpdateManyWithWhereWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    where: company_known_companiesScalarWhereInput
    data: XOR<company_known_companiesUpdateManyMutationInput, company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyInput>
  }

  export type notificationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutCompanyInput, notificationUncheckedUpdateWithoutCompanyInput>
    create: XOR<notificationCreateWithoutCompanyInput, notificationUncheckedCreateWithoutCompanyInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutCompanyInput, notificationUncheckedUpdateWithoutCompanyInput>
  }

  export type notificationUpdateManyWithWhereWithoutCompanyInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    ID?: BigIntFilter<"notification"> | bigint | number
    DATE?: DateTimeNullableFilter<"notification"> | Date | string | null
    NOTIFICATIONSTATUS?: StringNullableFilter<"notification"> | string | null
    NOTIFICATIONTYPE?: StringNullableFilter<"notification"> | string | null
    ORDERID?: StringNullableFilter<"notification"> | string | null
    TEXT?: StringNullableFilter<"notification"> | string | null
    COMPANYID?: BigIntNullableFilter<"notification"> | bigint | number | null
  }

  export type company_paymentoptionsUpsertWithWhereUniqueWithoutCompanyInput = {
    where: company_paymentoptionsWhereUniqueInput
    update: XOR<company_paymentoptionsUpdateWithoutCompanyInput, company_paymentoptionsUncheckedUpdateWithoutCompanyInput>
    create: XOR<company_paymentoptionsCreateWithoutCompanyInput, company_paymentoptionsUncheckedCreateWithoutCompanyInput>
  }

  export type company_paymentoptionsUpdateWithWhereUniqueWithoutCompanyInput = {
    where: company_paymentoptionsWhereUniqueInput
    data: XOR<company_paymentoptionsUpdateWithoutCompanyInput, company_paymentoptionsUncheckedUpdateWithoutCompanyInput>
  }

  export type company_paymentoptionsUpdateManyWithWhereWithoutCompanyInput = {
    where: company_paymentoptionsScalarWhereInput
    data: XOR<company_paymentoptionsUpdateManyMutationInput, company_paymentoptionsUncheckedUpdateManyWithoutCompanyInput>
  }

  export type company_paymentoptionsScalarWhereInput = {
    AND?: company_paymentoptionsScalarWhereInput | company_paymentoptionsScalarWhereInput[]
    OR?: company_paymentoptionsScalarWhereInput[]
    NOT?: company_paymentoptionsScalarWhereInput | company_paymentoptionsScalarWhereInput[]
    Company_ID?: BigIntFilter<"company_paymentoptions"> | bigint | number
    PAYMENTOPTIONS?: StringFilter<"company_paymentoptions"> | string
  }

  export type order_tableUpsertWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    where: order_tableWhereUniqueInput
    update: XOR<order_tableUpdateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedUpdateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput>
    create: XOR<order_tableCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput>
  }

  export type order_tableUpdateWithWhereUniqueWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    where: order_tableWhereUniqueInput
    data: XOR<order_tableUpdateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput, order_tableUncheckedUpdateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput>
  }

  export type order_tableUpdateManyWithWhereWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    where: order_tableScalarWhereInput
    data: XOR<order_tableUpdateManyMutationInput, order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput>
  }

  export type order_tableScalarWhereInput = {
    AND?: order_tableScalarWhereInput | order_tableScalarWhereInput[]
    OR?: order_tableScalarWhereInput[]
    NOT?: order_tableScalarWhereInput | order_tableScalarWhereInput[]
    ID?: BigIntFilter<"order_table"> | bigint | number
    CURRENCY?: StringNullableFilter<"order_table"> | string | null
    DATE?: StringNullableFilter<"order_table"> | string | null
    LASTPAYMENTREMINDER?: StringNullableFilter<"order_table"> | string | null
    NAME?: StringNullableFilter<"order_table"> | string | null
    NETAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    ORDERDATETIME?: DateTimeNullableFilter<"order_table"> | Date | string | null
    ORDERID?: StringNullableFilter<"order_table"> | string | null
    ORDERREFERENCE?: StringNullableFilter<"order_table"> | string | null
    ORDERSTATUS?: IntNullableFilter<"order_table"> | number | null
    PAYMENTSTATUS?: IntNullableFilter<"order_table"> | number | null
    TAXAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    TOTALAMOUNT?: FloatNullableFilter<"order_table"> | number | null
    FROMCOMPANY_ID?: BigIntNullableFilter<"order_table"> | bigint | number | null
    TOCOMPANY_ID?: BigIntNullableFilter<"order_table"> | bigint | number | null
  }

  export type order_tableUpsertWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    where: order_tableWhereUniqueInput
    update: XOR<order_tableUpdateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedUpdateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput>
    create: XOR<order_tableCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedCreateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput>
  }

  export type order_tableUpdateWithWhereUniqueWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    where: order_tableWhereUniqueInput
    data: XOR<order_tableUpdateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput, order_tableUncheckedUpdateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput>
  }

  export type order_tableUpdateManyWithWhereWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    where: order_tableScalarWhereInput
    data: XOR<order_tableUpdateManyMutationInput, order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput>
  }

  export type productUpsertWithWhereUniqueWithoutCompanyInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutCompanyInput, productUncheckedUpdateWithoutCompanyInput>
    create: XOR<productCreateWithoutCompanyInput, productUncheckedCreateWithoutCompanyInput>
  }

  export type productUpdateWithWhereUniqueWithoutCompanyInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutCompanyInput, productUncheckedUpdateWithoutCompanyInput>
  }

  export type productUpdateManyWithWhereWithoutCompanyInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutCompanyInput>
  }

  export type productScalarWhereInput = {
    AND?: productScalarWhereInput | productScalarWhereInput[]
    OR?: productScalarWhereInput[]
    NOT?: productScalarWhereInput | productScalarWhereInput[]
    ID?: BigIntFilter<"product"> | bigint | number
    DESCRIPTION?: StringNullableFilter<"product"> | string | null
    NAME?: StringNullableFilter<"product"> | string | null
    PRICE?: IntNullableFilter<"product"> | number | null
    PRODUCTAVAILABILITY?: StringNullableFilter<"product"> | string | null
    PRODUCTCATEGORYID?: StringNullableFilter<"product"> | string | null
    PRODUCTID?: StringNullableFilter<"product"> | string | null
    PRODUCTUNITOFMEASUREID?: StringNullableFilter<"product"> | string | null
    SYNCID?: IntNullableFilter<"product"> | number | null
    FROMCOMPANY_ID?: BigIntNullableFilter<"product"> | bigint | number | null
  }

  export type companyCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>
  }

  export type companyCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>
  }

  export type companyUpsertWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    update: XOR<companyUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput, companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>
    create: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput, companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput>
  }

  export type companyUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_company_idTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyUpsertWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    update: XOR<companyUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput, companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>
    create: XOR<companyCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput, companyUncheckedCreateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput, companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput>
  }

  export type companyUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyCreateWithoutCompany_paymentoptionsInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutCompany_paymentoptionsInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutCompany_paymentoptionsInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutCompany_paymentoptionsInput, companyUncheckedCreateWithoutCompany_paymentoptionsInput>
  }

  export type companyUpsertWithoutCompany_paymentoptionsInput = {
    update: XOR<companyUpdateWithoutCompany_paymentoptionsInput, companyUncheckedUpdateWithoutCompany_paymentoptionsInput>
    create: XOR<companyCreateWithoutCompany_paymentoptionsInput, companyUncheckedCreateWithoutCompany_paymentoptionsInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutCompany_paymentoptionsInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutCompany_paymentoptionsInput, companyUncheckedUpdateWithoutCompany_paymentoptionsInput>
  }

  export type companyUpdateWithoutCompany_paymentoptionsInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutCompany_paymentoptionsInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>
  }

  export type companyCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>
  }

  export type orderitemCreateWithoutOrder_tableInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    product?: productCreateNestedOneWithoutOrderitemInput
  }

  export type orderitemUncheckedCreateWithoutOrder_tableInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    PRODUCT_ID?: bigint | number | null
  }

  export type orderitemCreateOrConnectWithoutOrder_tableInput = {
    where: orderitemWhereUniqueInput
    create: XOR<orderitemCreateWithoutOrder_tableInput, orderitemUncheckedCreateWithoutOrder_tableInput>
  }

  export type orderitemCreateManyOrder_tableInputEnvelope = {
    data: orderitemCreateManyOrder_tableInput | orderitemCreateManyOrder_tableInput[]
    skipDuplicates?: boolean
  }

  export type companyUpsertWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    update: XOR<companyUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput, companyUncheckedUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>
    create: XOR<companyCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput, companyUncheckedUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput>
  }

  export type companyUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyUpsertWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    update: XOR<companyUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput, companyUncheckedUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>
    create: XOR<companyCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput, companyUncheckedCreateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput, companyUncheckedUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput>
  }

  export type companyUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type orderitemUpsertWithWhereUniqueWithoutOrder_tableInput = {
    where: orderitemWhereUniqueInput
    update: XOR<orderitemUpdateWithoutOrder_tableInput, orderitemUncheckedUpdateWithoutOrder_tableInput>
    create: XOR<orderitemCreateWithoutOrder_tableInput, orderitemUncheckedCreateWithoutOrder_tableInput>
  }

  export type orderitemUpdateWithWhereUniqueWithoutOrder_tableInput = {
    where: orderitemWhereUniqueInput
    data: XOR<orderitemUpdateWithoutOrder_tableInput, orderitemUncheckedUpdateWithoutOrder_tableInput>
  }

  export type orderitemUpdateManyWithWhereWithoutOrder_tableInput = {
    where: orderitemScalarWhereInput
    data: XOR<orderitemUpdateManyMutationInput, orderitemUncheckedUpdateManyWithoutOrder_tableInput>
  }

  export type orderitemScalarWhereInput = {
    AND?: orderitemScalarWhereInput | orderitemScalarWhereInput[]
    OR?: orderitemScalarWhereInput[]
    NOT?: orderitemScalarWhereInput | orderitemScalarWhereInput[]
    ID?: BigIntFilter<"orderitem"> | bigint | number
    INSTOCK?: StringNullableFilter<"orderitem"> | string | null
    NAME?: StringNullableFilter<"orderitem"> | string | null
    ORDERID?: IntNullableFilter<"orderitem"> | number | null
    ORDERITEMID?: IntNullableFilter<"orderitem"> | number | null
    QUANTITY?: IntNullableFilter<"orderitem"> | number | null
    SYNCID?: IntNullableFilter<"orderitem"> | number | null
    TOTAL?: DecimalNullableFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: StringNullableFilter<"orderitem"> | string | null
    UNITPRICE?: DecimalNullableFilter<"orderitem"> | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: BigIntNullableFilter<"orderitem"> | bigint | number | null
    PRODUCT_ID?: BigIntNullableFilter<"orderitem"> | bigint | number | null
  }

  export type order_tableCreateWithoutOrderitemInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    company_order_table_FROMCOMPANY_IDTocompany?: companyCreateNestedOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyInput
    company_order_table_TOCOMPANY_IDTocompany?: companyCreateNestedOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyInput
  }

  export type order_tableUncheckedCreateWithoutOrderitemInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    FROMCOMPANY_ID?: bigint | number | null
    TOCOMPANY_ID?: bigint | number | null
  }

  export type order_tableCreateOrConnectWithoutOrderitemInput = {
    where: order_tableWhereUniqueInput
    create: XOR<order_tableCreateWithoutOrderitemInput, order_tableUncheckedCreateWithoutOrderitemInput>
  }

  export type productCreateWithoutOrderitemInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
    company?: companyCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateWithoutOrderitemInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
    FROMCOMPANY_ID?: bigint | number | null
  }

  export type productCreateOrConnectWithoutOrderitemInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutOrderitemInput, productUncheckedCreateWithoutOrderitemInput>
  }

  export type order_tableUpsertWithoutOrderitemInput = {
    update: XOR<order_tableUpdateWithoutOrderitemInput, order_tableUncheckedUpdateWithoutOrderitemInput>
    create: XOR<order_tableCreateWithoutOrderitemInput, order_tableUncheckedCreateWithoutOrderitemInput>
    where?: order_tableWhereInput
  }

  export type order_tableUpdateToOneWithWhereWithoutOrderitemInput = {
    where?: order_tableWhereInput
    data: XOR<order_tableUpdateWithoutOrderitemInput, order_tableUncheckedUpdateWithoutOrderitemInput>
  }

  export type order_tableUpdateWithoutOrderitemInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    company_order_table_FROMCOMPANY_IDTocompany?: companyUpdateOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyNestedInput
    company_order_table_TOCOMPANY_IDTocompany?: companyUpdateOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyNestedInput
  }

  export type order_tableUncheckedUpdateWithoutOrderitemInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    TOCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type productUpsertWithoutOrderitemInput = {
    update: XOR<productUpdateWithoutOrderitemInput, productUncheckedUpdateWithoutOrderitemInput>
    create: XOR<productCreateWithoutOrderitemInput, productUncheckedCreateWithoutOrderitemInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutOrderitemInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutOrderitemInput, productUncheckedUpdateWithoutOrderitemInput>
  }

  export type productUpdateWithoutOrderitemInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companyUpdateOneWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutOrderitemInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type orderitemCreateWithoutProductInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    order_table?: order_tableCreateNestedOneWithoutOrderitemInput
  }

  export type orderitemUncheckedCreateWithoutProductInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: bigint | number | null
  }

  export type orderitemCreateOrConnectWithoutProductInput = {
    where: orderitemWhereUniqueInput
    create: XOR<orderitemCreateWithoutProductInput, orderitemUncheckedCreateWithoutProductInput>
  }

  export type orderitemCreateManyProductInputEnvelope = {
    data: orderitemCreateManyProductInput | orderitemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type companyCreateWithoutProductInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
  }

  export type companyUncheckedCreateWithoutProductInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    notification?: notificationUncheckedCreateNestedManyWithoutCompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
  }

  export type companyCreateOrConnectWithoutProductInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutProductInput, companyUncheckedCreateWithoutProductInput>
  }

  export type orderitemUpsertWithWhereUniqueWithoutProductInput = {
    where: orderitemWhereUniqueInput
    update: XOR<orderitemUpdateWithoutProductInput, orderitemUncheckedUpdateWithoutProductInput>
    create: XOR<orderitemCreateWithoutProductInput, orderitemUncheckedCreateWithoutProductInput>
  }

  export type orderitemUpdateWithWhereUniqueWithoutProductInput = {
    where: orderitemWhereUniqueInput
    data: XOR<orderitemUpdateWithoutProductInput, orderitemUncheckedUpdateWithoutProductInput>
  }

  export type orderitemUpdateManyWithWhereWithoutProductInput = {
    where: orderitemScalarWhereInput
    data: XOR<orderitemUpdateManyMutationInput, orderitemUncheckedUpdateManyWithoutProductInput>
  }

  export type companyUpsertWithoutProductInput = {
    update: XOR<companyUpdateWithoutProductInput, companyUncheckedUpdateWithoutProductInput>
    create: XOR<companyCreateWithoutProductInput, companyUncheckedCreateWithoutProductInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutProductInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutProductInput, companyUncheckedUpdateWithoutProductInput>
  }

  export type companyUpdateWithoutProductInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutProductInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    notification?: notificationUncheckedUpdateManyWithoutCompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
  }

  export type companyCreateWithoutNotificationInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    company_paymentoptions?: company_paymentoptionsCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutNotificationInput = {
    ID?: bigint | number
    BANKACCOUNTNR?: bigint | number | null
    CUSTOMERSTART?: Date | string | null
    ISACTIVE?: boolean | null
    LOGO?: string | null
    NAME?: string | null
    SECTOR?: string | null
    VATNUMBER?: string | null
    CITY?: string | null
    COUNTRY?: string | null
    NUMBER?: string | null
    STREET?: string | null
    ZIPCODE?: string | null
    EMAIL?: string | null
    PHONENUMBER?: string | null
    account?: accountUncheckedCreateNestedManyWithoutCompanyInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_company_idTocompanyInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedCreateNestedManyWithoutCompany_company_known_companies_known_company_idTocompanyInput
    company_paymentoptions?: company_paymentoptionsUncheckedCreateNestedManyWithoutCompanyInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedCreateNestedManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput
    product?: productUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutNotificationInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutNotificationInput, companyUncheckedCreateWithoutNotificationInput>
  }

  export type companyUpsertWithoutNotificationInput = {
    update: XOR<companyUpdateWithoutNotificationInput, companyUncheckedUpdateWithoutNotificationInput>
    create: XOR<companyCreateWithoutNotificationInput, companyUncheckedCreateWithoutNotificationInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutNotificationInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutNotificationInput, companyUncheckedUpdateWithoutNotificationInput>
  }

  export type companyUpdateWithoutNotificationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutNotificationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    BANKACCOUNTNR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CUSTOMERSTART?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ISACTIVE?: NullableBoolFieldUpdateOperationsInput | boolean | null
    LOGO?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    SECTOR?: NullableStringFieldUpdateOperationsInput | string | null
    VATNUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    COUNTRY?: NullableStringFieldUpdateOperationsInput | string | null
    NUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    ZIPCODE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PHONENUMBER?: NullableStringFieldUpdateOperationsInput | string | null
    account?: accountUncheckedUpdateManyWithoutCompanyNestedInput
    company_known_companies_company_known_companies_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyNestedInput
    company_known_companies_company_known_companies_known_company_idTocompany?: company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyNestedInput
    company_paymentoptions?: company_paymentoptionsUncheckedUpdateManyWithoutCompanyNestedInput
    order_table_order_table_FROMCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyNestedInput
    order_table_order_table_TOCOMPANY_IDTocompany?: order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyNestedInput
    product?: productUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type accountCreateManyCompanyInput = {
    ID?: bigint | number
    EMAIL?: string | null
    PASSWORD?: string | null
    ROLE?: number | null
  }

  export type company_known_companiesCreateManyCompany_company_known_companies_company_idTocompanyInput = {
    known_company_id: bigint | number
  }

  export type company_known_companiesCreateManyCompany_company_known_companies_known_company_idTocompanyInput = {
    company_id: bigint | number
  }

  export type notificationCreateManyCompanyInput = {
    ID?: bigint | number
    DATE?: Date | string | null
    NOTIFICATIONSTATUS?: string | null
    NOTIFICATIONTYPE?: string | null
    ORDERID?: string | null
    TEXT?: string | null
  }

  export type company_paymentoptionsCreateManyCompanyInput = {
    PAYMENTOPTIONS: string
  }

  export type order_tableCreateManyCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    TOCOMPANY_ID?: bigint | number | null
  }

  export type order_tableCreateManyCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: bigint | number
    CURRENCY?: string | null
    DATE?: string | null
    LASTPAYMENTREMINDER?: string | null
    NAME?: string | null
    NETAMOUNT?: number | null
    ORDERDATETIME?: Date | string | null
    ORDERID?: string | null
    ORDERREFERENCE?: string | null
    ORDERSTATUS?: number | null
    PAYMENTSTATUS?: number | null
    TAXAMOUNT?: number | null
    TOTALAMOUNT?: number | null
    FROMCOMPANY_ID?: bigint | number | null
  }

  export type productCreateManyCompanyInput = {
    ID?: bigint | number
    DESCRIPTION?: string | null
    NAME?: string | null
    PRICE?: number | null
    PRODUCTAVAILABILITY?: string | null
    PRODUCTCATEGORYID?: string | null
    PRODUCTID?: string | null
    PRODUCTUNITOFMEASUREID?: string | null
    SYNCID?: number | null
  }

  export type accountUpdateWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    ROLE?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accountUncheckedUpdateWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    ROLE?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accountUncheckedUpdateManyWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PASSWORD?: NullableStringFieldUpdateOperationsInput | string | null
    ROLE?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type company_known_companiesUpdateWithoutCompany_company_known_companies_company_idTocompanyInput = {
    company_company_known_companies_known_company_idTocompany?: companyUpdateOneRequiredWithoutCompany_known_companies_company_known_companies_known_company_idTocompanyNestedInput
  }

  export type company_known_companiesUncheckedUpdateWithoutCompany_company_known_companies_company_idTocompanyInput = {
    known_company_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_company_idTocompanyInput = {
    known_company_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type company_known_companiesUpdateWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    company_company_known_companies_company_idTocompany?: companyUpdateOneRequiredWithoutCompany_known_companies_company_known_companies_company_idTocompanyNestedInput
  }

  export type company_known_companiesUncheckedUpdateWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type company_known_companiesUncheckedUpdateManyWithoutCompany_company_known_companies_known_company_idTocompanyInput = {
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type notificationUpdateWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NOTIFICATIONSTATUS?: NullableStringFieldUpdateOperationsInput | string | null
    NOTIFICATIONTYPE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    TEXT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationUncheckedUpdateWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NOTIFICATIONSTATUS?: NullableStringFieldUpdateOperationsInput | string | null
    NOTIFICATIONTYPE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    TEXT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationUncheckedUpdateManyWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NOTIFICATIONSTATUS?: NullableStringFieldUpdateOperationsInput | string | null
    NOTIFICATIONTYPE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    TEXT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_paymentoptionsUpdateWithoutCompanyInput = {
    PAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type company_paymentoptionsUncheckedUpdateWithoutCompanyInput = {
    PAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type company_paymentoptionsUncheckedUpdateManyWithoutCompanyInput = {
    PAYMENTOPTIONS?: StringFieldUpdateOperationsInput | string
  }

  export type order_tableUpdateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    company_order_table_TOCOMPANY_IDTocompany?: companyUpdateOneWithoutOrder_table_order_table_TOCOMPANY_IDTocompanyNestedInput
    orderitem?: orderitemUpdateManyWithoutOrder_tableNestedInput
  }

  export type order_tableUncheckedUpdateWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderitem?: orderitemUncheckedUpdateManyWithoutOrder_tableNestedInput
  }

  export type order_tableUncheckedUpdateManyWithoutCompany_order_table_FROMCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type order_tableUpdateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    company_order_table_FROMCOMPANY_IDTocompany?: companyUpdateOneWithoutOrder_table_order_table_FROMCOMPANY_IDTocompanyNestedInput
    orderitem?: orderitemUpdateManyWithoutOrder_tableNestedInput
  }

  export type order_tableUncheckedUpdateWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderitem?: orderitemUncheckedUpdateManyWithoutOrder_tableNestedInput
  }

  export type order_tableUncheckedUpdateManyWithoutCompany_order_table_TOCOMPANY_IDTocompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    CURRENCY?: NullableStringFieldUpdateOperationsInput | string | null
    DATE?: NullableStringFieldUpdateOperationsInput | string | null
    LASTPAYMENTREMINDER?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    NETAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    ORDERDATETIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ORDERID?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERREFERENCE?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    PAYMENTSTATUS?: NullableIntFieldUpdateOperationsInput | number | null
    TAXAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    TOTALAMOUNT?: NullableFloatFieldUpdateOperationsInput | number | null
    FROMCOMPANY_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type productUpdateWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    orderitem?: orderitemUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    orderitem?: orderitemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutCompanyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PRICE?: NullableIntFieldUpdateOperationsInput | number | null
    PRODUCTAVAILABILITY?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTCATEGORYID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTID?: NullableStringFieldUpdateOperationsInput | string | null
    PRODUCTUNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderitemCreateManyOrder_tableInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    PRODUCT_ID?: bigint | number | null
  }

  export type orderitemUpdateWithoutOrder_tableInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product?: productUpdateOneWithoutOrderitemNestedInput
  }

  export type orderitemUncheckedUpdateWithoutOrder_tableInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    PRODUCT_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type orderitemUncheckedUpdateManyWithoutOrder_tableInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    PRODUCT_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type orderitemCreateManyProductInput = {
    ID?: bigint | number
    INSTOCK?: string | null
    NAME?: string | null
    ORDERID?: number | null
    ORDERITEMID?: number | null
    QUANTITY?: number | null
    SYNCID?: number | null
    TOTAL?: Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: string | null
    UNITPRICE?: Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: bigint | number | null
  }

  export type orderitemUpdateWithoutProductInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    order_table?: order_tableUpdateOneWithoutOrderitemNestedInput
  }

  export type orderitemUncheckedUpdateWithoutProductInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type orderitemUncheckedUpdateManyWithoutProductInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    INSTOCK?: NullableStringFieldUpdateOperationsInput | string | null
    NAME?: NullableStringFieldUpdateOperationsInput | string | null
    ORDERID?: NullableIntFieldUpdateOperationsInput | number | null
    ORDERITEMID?: NullableIntFieldUpdateOperationsInput | number | null
    QUANTITY?: NullableIntFieldUpdateOperationsInput | number | null
    SYNCID?: NullableIntFieldUpdateOperationsInput | number | null
    TOTAL?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    UNITOFMEASUREID?: NullableStringFieldUpdateOperationsInput | string | null
    UNITPRICE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    FROMORDER_ID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Order_tableCountOutputTypeDefaultArgs instead
     */
    export type Order_tableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Order_tableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use accountDefaultArgs instead
     */
    export type accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use companyDefaultArgs instead
     */
    export type companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = companyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use company_known_companiesDefaultArgs instead
     */
    export type company_known_companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = company_known_companiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use company_paymentoptionsDefaultArgs instead
     */
    export type company_paymentoptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = company_paymentoptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use company_update_requestsDefaultArgs instead
     */
    export type company_update_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = company_update_requestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use companyupdaterequest_newpaymentoptionsDefaultArgs instead
     */
    export type companyupdaterequest_newpaymentoptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = companyupdaterequest_newpaymentoptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_tableDefaultArgs instead
     */
    export type order_tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_tableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderitemDefaultArgs instead
     */
    export type orderitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderitemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productDefaultArgs instead
     */
    export type productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationDefaultArgs instead
     */
    export type notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}